---
layout: "@layouts/MDLayout.astro"
title: Dynamic Programming - CSES Problem Set Solutions
description: My solutions and thoughts for the CSES problem set!
keywords: ["cp", "competitive programming", "leetcode", "algorithms", "data structures"]
---

import AlignLatex from "@components/latex/AlignLatex";
import DisplayLatex from "@components/latex/DisplayLatex";
import Eqref from "@components/latex/Eqref";
import GatherLatex from "@components/latex/GatherLatex";
import Eq from "@components/latex/Eq";
import Trl from "@components/latex/TableRowLatex";
import Trhl from "@components/latex/TableRowHLatex";

import FigImg from "@components/figures/FigImg";
import FiguresBlock from "@components/figures/FiguresBlock";
import Fig from "@components/figures/Fig";

import Code from "@components/Code.astro";
import SpoilerBlock from "@components/SpoilerBlock.astro";
import Todo from "@components/Todo";

import Spec from "./../_shared.Spec.astro"; //_
import Intro from "./_common.intro.astro"; //_

import DArr from "./_common.DArr.astro"; //_
import UArr from "./_common.UArr.astro"; //_
import LArr from "./_common.LArr.astro"; //_
import RArr from "./_common.RArr.astro"; //_
import DLArr from "./_common.DLArr.astro"; //_
import URArr from "./_common.URArr.astro"; //_


<Intro />


## Dice Combinations <Spec href="https://cses.fi/problemset/task/1633" cdate="2024-03-13" />

The subproblem is simply a Fibonacci-esque recursive function:

<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_n = F_{n-1} + F_{n-2} + F_{n-3} + F_{n-4} + F_{n-5} + F_{n-6}
    \quad\text{for}\quad n > 0
" />

With DP, this runs in <Eq code="O(n)" /> time. Considering how the input bounds set <Eq code="n \le {10}^6" />, a test case can in theory run a hotspot <Eq code="6 \times {10}^6" /> times.

We choose <Eq code="F_{n-1}" /> through to <Eq code="F_{n-6}" /> since we know each dice roll has to be integers 1-6.

My first attempt was a top-down implementation, though it comes to no surprise that it causes runtime errors (presumably stack overflow):

import SolDiceCombinations01 from "./_solutions.dynamic-programming/dice-combinations--01-fail-stackoverflow.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (Stack Overflow)">
    <Code code={SolDiceCombinations01} lang="py" />
</SpoilerBlock>

Setting a higher `setrecursionlimit` fixed the runtime errors, but instead TLE's. Not too surprising. Implementation:

import SolDiceCombinations02 from "./_solutions.dynamic-programming/dice-combinations--02-fail-tle.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (TLE)">
    <Code code={SolDiceCombinations02} lang="py" />
</SpoilerBlock>

Switching to a simple top-down approach passed all tests (worst-case runtime in CPython and PyPy3 was 1.00s and 0.22s, respectively):

import SolDiceCombinations03 from "./_solutions.dynamic-programming/dice-combinations--03-pass.py?raw" //_

<Code code={SolDiceCombinations03} lang="py" />

Switching to only storing a fixed-size window reduced the worst test case runtimes to 0.44s and 0.13s (CPython and PyPy3, respectively):

import SolDiceCombinations04 from "./_solutions.dynamic-programming/dice-combinations--04-pass.py?raw" //_

<Code code={SolDiceCombinations04} lang="py" />

Making it so we don't re-add all six elements of `tab` anymore turned out to perform worse:

import SolDiceCombinations05 from "./_solutions.dynamic-programming/dice-combinations--05-pass.py?raw" //_

<Code code={SolDiceCombinations05} lang="py" />


## Minimizing Coins <Spec href="https://cses.fi/problemset/task/1634" cdate="2024-03-31" />

The first subproblem that comes to mind is, for every integer from <Eq code="0" /> to <Eq code="x" />, we find the fewest number of coins possible. Runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = \infty
    \qquad
    F_0 = 0
    \\
    F_x = \min_{c \in C}\parens{
        F_{x - c}
    } + 1
    \quad\text{for}\quad x > 0
" />

Considering how the input bounds set <Eq code="n \le 100" /> and <Eq code="x \le {10}^6" />, a test case can in theory run a hotspot <Eq code="{10}^8" /> times. Assuming a similar style of implementation to my first Dice Combinations passed solution which had a worst runtime of 0.22s, it doesn't sound like Minimizing Coins in Python should pass since we get a hotspot running at least 10x as many times.

For fun, we start with a Python top-down solution, as well as bottom-up, and I also tried an optimization that precomputes some trivial table entries. The logic appears correct, but they TLE as expected:

import SolMinimizingCoins01 from "./_solutions.dynamic-programming/minimizing-coins--01-fail-tle-topdown.py?raw" //_
import SolMinimizingCoins02 from "./_solutions.dynamic-programming/minimizing-coins--02-fail-tle-bottomup.py?raw" //_
import SolMinimizingCoins03 from "./_solutions.dynamic-programming/minimizing-coins--03-fail-tle-added-precomputes.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolMinimizingCoins01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution (TLE)">
    <Code code={SolMinimizingCoins02} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution With Optimization (TLE)">
    <Code code={SolMinimizingCoins03} lang="py" />
</SpoilerBlock>

Implementing the bottom-up approach in C++ passed all tests (with a longest runtime of 0.15s):

import SolMinimizingCoins05 from "./_solutions.dynamic-programming/minimizing-coins--05-pass-bottomup.cpp?raw" //_

<Code code={SolMinimizingCoins05} lang="cpp" />


## Coin Combinations I <Spec href="https://cses.fi/problemset/task/1635" cdate="2024-04-01" />

Different orderings of the same set of coins count as different combinations, which makes subproblem selection easier. My chosen subproblem is to find the number of combinations for each possible target sum <Eq code="0" /> to <Eq code="x" />. For <Eq code="n" /> coins, the runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_x = \sum_{c \in C}{
        F_{x - c}
    }
    \quad\text{for}\quad x > 0
" />

Input bounds are similar to Minimizing Coins, so a hotspot possibly runs <Eq code="{10}^8" /> times, and is similarly unlikely to pass using Python.

But let's write a top-down Python implementation anyway! As expected, it TLE's:

import SolCoinCombinationsI01 from "./_solutions.dynamic-programming/coin-combinations-i--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolCoinCombinationsI01} lang="py" />
</SpoilerBlock>

Implementing bottom-up in C++ passes all tests:

import SolCoinCombinationsI02 from "./_solutions.dynamic-programming/coin-combinations-i--02-pass-bottomup.cpp?raw" //_

<Code code={SolCoinCombinationsI02} lang="cpp" />


## Coin Combinations II [UNFINISHED] <Spec href="https://cses.fi/problemset/task/1636" cdate="2024-04-01" />

If we used the strategy from Coin Combinations I, we run into the problem of needing to avoid double-counting combinations. To deal with this, maybe we need a two-dimensional table: one dimension for coin value, and another dimension for coin sum. The following subproblem comes to mind, which may naively run in <Eq code="O(x^2 n)" /> time:

<DisplayLatex code="
    C = \braces{c_1, \dots, c_n} = \text{set of all coin values}
" />
<GatherLatex code="
    F\brackets{0, x} =
    \begin{cases}
        1 &\text{ if } x = 0 \\
        0 &\text{ otherwise}
    \end{cases}
    \\
    F\brackets{i, x} =
    \begin{cases}
        \displaystyle
        0 \vphantom{\sum_C^A}
        &\text{ if } x < 0 \\
        \displaystyle
        \sum_{j = 0}^{\infty}{
            F\brackets{i - 1, x - j c_i}
        }
        &\text{ otherwise}
    \end{cases}
" />

I say "naively" because there may be a way to cut that runtime to <Eq code="O(xn)" /> with a clever optimization. I'll get to my idea for that later.

I am very certain it will TLE (even if I were to add the optimization), but I made an <Eq code="O(x^2 n)" /> top-down Python implementation anyway just for fun. It passes some tests, but TLE's everything else. Good to know that we're not getting any wrong answers! Implementation:

import SolCoinCombinationsII01 from "./_solutions.dynamic-programming/coin-combinations-ii--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolCoinCombinationsII01} lang="py" />
</SpoilerBlock>

<Todo>Continue this!</Todo>

