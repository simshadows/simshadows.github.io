---
layout: ../../../../layouts/MDLayout.astro
title: Advent of Code 2023 Solutions
description: My solutions and thoughts for Advent of Code 2023!
keywords: ["advent of code", "2023", "day", "part", "solutions", "thoughts", "python"]
---

import Divider from "../_shared.Divider.astro"; //_
import Spec from "../_shared.Spec.astro"; //_

All solutions on this page were written by me without reading any hints or solutions.

My solutions aren't necessarily great, but they did the job and got me the answers.

My suggestion to run these solutions:
```
$ cat input.txt | ./solution.py
```


<Divider />

## Day 1 <Spec href="https://adventofcode.com/2023/day/1" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    n = 0
    for s in f.readlines():
        s = [c for c in s if (c in "1234567890")]
        n += int(s[0] + s[-1])
    print(n)

run(stdin)
```

### Part 2 Failure

I found Part 2 to be a pain in the ass because the exact conditions for a word to count as a number weren't clear.

My first attempt would replace all valid substrings into digits, giving priority to what appears earlier:

```py
#!/usr/bin/env python3

from sys import stdin
from math import isinf, inf

nums = {str(s) for s in range(10)}
tab = {
    "one": "1",
    "two": "2",
    "three": "3",
    "four": "4",
    "five": "5",
    "six": "6",
    "seven": "7",
    "eight": "8",
    "nine": "9",
    #"zero": "0",
}

def run():
    n = 0
    for i, s in enumerate(x.strip() for x in f.readlines()):
        while True:
            best_idx = inf
            best_str = ""
            for (query, digit) in tab.items():
                idx = s.find(query)
                if idx >= 0 and idx < best_idx:
                    best_idx = idx
                    best_str = query
            if isinf(best_idx):
                break
            s = s.replace(best_str, tab[best_str], 1)
        s = list(filter(lambda x : x in nums, s))
        n += int(s[0] + s[-1])
    print(n)

run(f)
```

### Part 2 Solution

After a bit more thought, I realized the important thing is probably the first and last actual valid word.

In the interest of getting something done quick, I produced a terribly inelegant solution. Both the `#replace first` and `#replace last` blocks of code are near identical and do the same thing, just at different ends of the string. In the case of `#replace first`, it:

1. finds the left-most valid substring,
2. replaces it with a digit (if there is such a substring), then
3. removes all non-numerical character.

The full solution:

```py
#!/usr/bin/env python3

from sys import stdin
from math import isinf, inf

nums = {str(s) for s in range(10)}
tab = {
    "one": "1",
    "two": "2",
    "three": "3",
    "four": "4",
    "five": "5",
    "six": "6",
    "seven": "7",
    "eight": "8",
    "nine": "9",
    #"zero": "0",
}

def run(f):
    n = 0
    for i, s in enumerate(x.strip() for x in f.readlines()):
        # replace first
        s1 = s
        best_idx = inf
        best_str = ""
        for (query, digit) in tab.items():
            idx = s1.find(query)
            if idx >= 0 and idx < best_idx:
                best_idx = idx
                best_str = query
        if not isinf(best_idx):
            s1 = s1.replace(best_str, tab[best_str], 1)
        s1 = [c for c in s1 if (c in nums)]

        # replace last
        s2 = s
        best_idx = -1
        best_str = ""
        for (query, digit) in tab.items():
            idx = s2.rfind(query)
            if idx >= 0 and idx > best_idx:
                best_idx = idx
                best_str = query
        if best_idx >= 1:
            s2 = s2.replace(best_str, tab[best_str])
        s2 = [c for c in s2 if (c in nums)]

        n += int(s1[0] + s2[-1])
    print(n)

run(stdin)
```


<Divider />

## Day 2 <Spec href="https://adventofcode.com/2023/day/2" />

### Part 1 Solution

My solution just checks if every number of cubes falls within the limits (`R_LIMIT`, `G_LIMIT`, and `B_LIMIT`).

```py
#!/usr/bin/env python3

from sys import stdin

R_LIMIT = 12
G_LIMIT = 13
B_LIMIT = 14

def run(f):
    solution = 0
    for i, s in enumerate(f.readlines()):
        (title, tail) = s.strip().split(":")
        (_, game_num) = title.split()
        sets = [dict(reversed(y.split()) for y in x.split(",")) for x in tail.split(";")]

        game_is_possible = all(
            (
                int(d.get("red", 0)) <= R_LIMIT
                and int(d.get("green", 0)) <= G_LIMIT
                and int(d.get("blue", 0)) <= B_LIMIT
            )
            for d in sets
        )
        if game_is_possible:
            solution += int(game_num)
    print(solution)

run(stdin)
```

### Part 2 Solution

Straightforward modification that instead just grabs the maximum numbers of red, green, and blue seen within each game.

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    solution = 0
    for i, s in enumerate(f.readlines()):
        (title, tail) = s.strip().split(":")
        (_, game_num) = title.split()
        sets = [dict(reversed(y.split()) for y in x.split(",")) for x in tail.split(";")]

        (r, g, b) = (0, 0, 0)
        for d in sets:
            r = max(r, int(d.get("red", 0)))
            g = max(g, int(d.get("green", 0)))
            b = max(b, int(d.get("blue", 0)))
        solution += r * g * b
    print(solution)

run(stdin)
```


<Divider />

## Day 3 <Spec href="https://adventofcode.com/2023/day/3" />

### Part 1 Solution

This one's a real mess to look at due to the loop nesting (2D data structures can be a pain like this) and lots of things happening simultaneously.

My approach starts by padding the grid with an extra end column and end row of `"."`, i.e. the symbol denoting empty space. This simplifies the code since we need to check adjacent cells, and `"."` will simply be read as nothing.

This padding also takes advantage of Python's negative indexing, where `row[-1]` will simply grab the final element of the row (i.e. the final column). For example, if our current location is `(1, 0)` (row 1, column 0), our adjacent cells will include the negative column: `(0, -1)`, `(1, -1)`, and `(2, -1)`. These negative column numbers will just map to the final column, which will all be `"."`. In my opinion, this is a nice simplification that means we no longer have to explicitly deal with the edge case within the loop.

The loop itself scans each row for consecutive digits. Every time a digit is found, it updates an accumulator (called `num`). E.g. if the accumulator is `452` and we read in a new digit `7`, the accumulator now becomes `4527`. Every time we read in a non-digit, the accumulator is *flushed*, resetting it to zero.

At the same time, we also scan all adjacent cells for part symbols (`*`, `#`, etc.). If it is, then we record the current accumulator as being a part number (`is_part_num`). That way, by the time the accumulator flushes, we know whether the full number is indeed a part number.

Once again, the `"."` padding helps us simplify our code to avoid explicitly dealing with an edge case. Since the final column is `"."`, we will know that any part number still stored in the accumulator will be forced to flush, and thus be included in the solution.

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

def run(f):
    solution = 0
    grid = [list(x.strip()) + ["."] for x in f]
    (len1, len2) = (len(grid), len(grid[0]))
    grid.append(["."] * len2)
    for i, row in enumerate(grid):
        (num, is_part_num) = (0, False)
        for j, v in enumerate(row):
            if v.isdigit():
                num = (num * 10) + int(v)
                for i2, j2 in product((i - 1, i, i + 1), (j - 1, j, j + 1)):
                    (i2, j2) = (i2 % len1, j2 % len2)
                    if (not grid[i2][j2].isdigit()) and (grid[i2][j2] != "."):
                        is_part_num = True
            else:
                if is_part_num:
                    solution += num
                (num, is_part_num) = (0, False)
    print(solution)

run(stdin)
```

### Part 2 Solution

We keep a lot of the same tricks as Part 1, but this time, instead of `is_part_num`, we store a set of adjacent gears (`gears`) to the current accumulator value. Every time we *flush* the accumulator, we record every gear we found as being adjacent to the part number (`gear_adjs`).

Then, we just loop through `gear_adjs`, summing up gear ratios (`x[0] * x[1]`) after filtering for gears with exactly two adjacencies (`len(x) == 2`).

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product
from collections import defaultdict

def run(f):
    grid = [x.strip() + "." for x in f]
    (len1, len2) = (len(grid), len(grid[0]))
    grid.append("." * len2)
    gear_adjs = defaultdict(list) # "gear adjacencies", {(i, j): [part nums]}
    for i, row in enumerate(grid):
        (num, gears) = (0, set())
        for j, v in enumerate(row):
            if v.isdigit():
                num = (num * 10) + int(v)
                for i2, j2 in product((i - 1, i, i + 1), (j - 1, j, j + 1)):
                    (i2, j2) = (i2 % len1, j2 % len2)
                    if grid[i2][j2] == "*":
                        gears.add((i2, j2))
            else:
                for i2, j2 in gears:
                    gear_adjs[(i2, j2)].append(num)
                (num, gears) = (0, set())
    print(sum(x[0] * x[1] for x in gear_adjs.values() if len(x) == 2))

run(stdin)
```


<Divider />

## Day 4 <Spec href="https://adventofcode.com/2023/day/4" />

### Part 1 Solution

We just take a set intersection between what's present on the card and the winning numbers to get the number of winning numbers. Easy!

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    solution = 0
    for line in f:
        (_, all_numbers) = line.split(":")
        (card, winning_numbers) = [x.strip().split() for x in all_numbers.strip().split("|")]
        matches = len(set(card) & set(winning_numbers))
        if matches > 0:
            solution += 2 ** (matches - 1)
    print(solution)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    cards = []
    for line in f:
        (_, all_numbers) = line.split(":")
        (card, winning_numbers) = [x.strip().split() for x in all_numbers.strip().split("|")]
        cards.append(len(set(card) & set(winning_numbers)))

    solution = 0
    for i, v in reversed(list(enumerate(cards))):
        cards[i] = sum(cards[i+1:i+1+cards[i]]) + 1
        solution += cards[i]
    print(solution)

run(stdin)
```


<Divider />

## Day 5 <Spec href="https://adventofcode.com/2023/day/5" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin

maps_order = (
    "seed-to-soil map",
    "soil-to-fertilizer map",
    "fertilizer-to-water map",
    "water-to-light map",
    "light-to-temperature map",
    "temperature-to-humidity map",
    "humidity-to-location map",
)

def run(f):
    sections = [x.split(":") for x in "".join(f.readlines()).split("\n\n")]
    sections = {k.strip(): v.strip() for k, v in sections}

    seeds = [int(x) for x in sections["seeds"].split()]
    del sections["seeds"]

    maps = {k: [[int(y) for y in x.split()] for x in v.split("\n")] for k, v in sections.items()}

    ids = seeds
    for map_name in maps_order:
        ranges = maps[map_name]
        new_ids = []
        for i in ids:
            new_i = i
            for dst, src, rangelen in ranges:
                if (i >= src) and (i < src + rangelen):
                    new_i = dst + (i - src)
                    break
            new_ids.append(new_i)
        ids = new_ids
    print(min(ids))

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import chain, pairwise, zip_longest

maps_order = (
    "seed-to-soil map",
    "soil-to-fertilizer map",
    "fertilizer-to-water map",
    "water-to-light map",
    "light-to-temperature map",
    "temperature-to-humidity map",
    "humidity-to-location map",
)

def grouper(iterable, n, *, incomplete='fill', fillvalue=None):
    "Collect data into non-overlapping fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, fillvalue='x') --> ABC DEF Gxx
    # grouper('ABCDEFG', 3, incomplete='strict') --> ABC DEF ValueError
    # grouper('ABCDEFG', 3, incomplete='ignore') --> ABC DEF
    args = [iter(iterable)] * n
    if incomplete == 'fill':
        return zip_longest(*args, fillvalue=fillvalue)
    if incomplete == 'strict':
        return zip(*args, strict=True)
    if incomplete == 'ignore':
        return zip(*args)
    else:
        raise ValueError('Expected fill, strict, or ignore')

def run(f):
    sections = [x.split(":") for x in "".join(f.readlines()).split("\n\n")]
    sections = {k.strip(): v.strip() for k, v in sections}

    seeds = list(grouper((int(x) for x in sections["seeds"].split()), 2))
    del sections["seeds"]

    maps = {k: [[int(y) for y in x.split()] for x in v.split("\n")] for k, v in sections.items()}

    ids = seeds
    for map_name in maps_order:
        ranges = maps[map_name]
        new_ids = []
        while len(ids):
            id_start, id_len = ids.pop()
            if id_len == 0:
                continue
            for dst, src, rangelen in ranges:
                intersect_start = max(id_start, src)
                intersect_end = min(id_start + id_len, src + rangelen)
                if intersect_end > intersect_start:
                    ids.append((id_start, intersect_start - id_start))
                    ids.append((intersect_end, id_start + id_len - intersect_end))
                    new_ids.append((intersect_start + dst - src, intersect_end - intersect_start))
                    break
            else:
                new_ids.append((id_start, id_len))
        ids = new_ids
    print(min((x for (x, _) in ids), default="NONE"))

run(stdin)
```


<Divider />

## Day 6 <Spec href="https://adventofcode.com/2023/day/6" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    sections = [s.split(":") for s in f.readlines()]
    sections = {k.strip(): [int(x) for x in v.strip().split()] for k, v in sections}

    solution = 1
    for time_limit, dist_record in zip(sections["Time"], sections["Distance"]):
        combos = 0
        for hold_time in range(1, time_limit):
            dist_travelled = (time_limit - hold_time) * hold_time
            if dist_travelled > dist_record:
                combos += 1
        solution *= combos

    print(solution)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    sections = [s.split(":") for s in f.readlines()]
    sections = {k.strip(): int("".join(v.strip().split())) for k, v in sections}

    (time_limit, dist_record) = (sections["Time"], sections["Distance"])

    combos = 0
    for hold_time in range(1, time_limit):
        dist_travelled = (time_limit - hold_time) * hold_time
        if dist_travelled > dist_record:
            combos += 1

    print(combos)

run(stdin)
```


<Divider />

## Day 7 <Spec href="https://adventofcode.com/2023/day/7" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from collections import Counter
from itertools import chain, count

label_order = {c: i for c, i in zip(reversed("AKQJT98765432"), count())}

def run(f):
    hands = [s.split() for s in f.readlines()]

    sorted_hands = [[], [], [], [], [], [], []]
    for labels, bid in hands:
        bid = int(bid)
        cnt = Counter(labels)
        freqs = Counter(cnt.values())

        tup = (tuple(label_order[c] for c in labels), bid)
        if 5 in freqs:
            sorted_hands[6].append(tup)
        elif 4 in freqs:
            sorted_hands[5].append(tup)
        elif 3 in freqs:
            if 2 in freqs:
                sorted_hands[4].append(tup)
            else:
                sorted_hands[3].append(tup)
        elif freqs[2] == 2:
            sorted_hands[2].append(tup)
        elif freqs[2] == 1:
            sorted_hands[1].append(tup)
        else:
            sorted_hands[0].append(tup)

    all_sorted = chain(*(tuple(sorted(lst)) for lst in sorted_hands))
    print(sum(bid * rank for ((_, bid), rank) in zip(all_sorted, count(1))))

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from collections import Counter
from itertools import chain, count

label_order = {c: i for c, i in zip(reversed("AKQT98765432J"), count())}

def run(f):
    hands = [s.split() for s in f.readlines()]

    sorted_hands = [[], [], [], [], [], [], []]
    for labels, bid in hands:
        bid = int(bid)

        tup = (tuple(label_order[c] for c in labels), bid)
        strength = -1
        for joker_mimic in "AKQT98765432J":
            mimicked = labels.replace("J", joker_mimic)
            print(mimicked)
            cnt = Counter(mimicked)
            freqs = Counter(cnt.values())

            if 5 in freqs:
                strength = max(strength, 6)
            elif 4 in freqs:
                strength = max(strength, 5)
            elif 3 in freqs:
                if 2 in freqs:
                    strength = max(strength, 4)
                else:
                    strength = max(strength, 3)
            elif freqs[2] == 2:
                strength = max(strength, 2)
            elif freqs[2] == 1:
                strength = max(strength, 1)
            else:
                strength = max(strength, 0)
        sorted_hands[strength].append(tup)

    all_sorted = chain(*(tuple(sorted(lst)) for lst in sorted_hands))
    print(sum(bid * rank for ((_, bid), rank) in zip(all_sorted, count(1))))

run(stdin)
```


<Divider />

## Day 8 <Spec href="https://adventofcode.com/2023/day/8" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    (instructions, graph) = f.read().strip().split("\n\n")
    graph = {x[0]: (x[2][1:-1], x[3][:-1]) for x in (s.split() for s in graph.split("\n"))}

    steps = 0
    cur = "AAA"
    while cur != "ZZZ":
        cur = graph[cur][0] if (instructions[steps % len(instructions)] == "L") else graph[cur][1]
        steps += 1
    print(steps)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import cycle
from math import lcm

def run(f):
    (instructions, graph) = f.read().strip().split("\n\n")
    instructions = [(0 if x == "L" else 1) for x in instructions]
    graph = {x[0]: (x[2][1:-1], x[3][:-1]) for x in (s.split() for s in graph.split("\n"))}

    starts = list({x for x in graph.keys() if x[-1] == "A"})
    cycle_exits = []
    cycle_bounds = []
    for i, start in enumerate(starts):
        seen = {} # {(node, instruction order): step, ...}
        cycle_exits.append([])
        cur = start
        for step, (j, instr) in enumerate(cycle(enumerate(instructions))):
            tup = (cur, j)
            if tup in seen:
                cycle_bounds.append((seen[tup], step))
                break
            if cur[-1] == "Z":
                cycle_exits[-1].append(step)
            seen[tup] = step
            cur = graph[cur][instr]
    print("exits:", cycle_exits)
    print()
    print("bounds:", cycle_bounds)
    print()

    # the rest of this code works only because we know there is only exactly one exit for
    # each cycle
    if any(len(x) != 1 for x in cycle_exits):
        raise RuntimeError()

    # also, we ignore any steps before they all enter a cycle
    offset = max(start for (start, _) in cycle_bounds)
    cycle_lens = [end - start for (start, end) in cycle_bounds]
    first_exit = [x[0] - offset for x in cycle_exits]
    diffs = [cl - fe for cl, fe in zip(cycle_lens, first_exit)]

    print("cycle lengths - first exit:", diffs)
    print()

    # the rest of the code below assumes the same difference!
    if any(x != diffs[0] for x in diffs):
        raise RuntimeError()
    
    print(lcm(*cycle_lens))

run(stdin)
```


<Divider />

## Day 9 <Spec href="https://adventofcode.com/2023/day/9" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import pairwise

def run(f):
    seqs = [[int(x) for x in s.split()] for s in f.readlines()]

    solution = 0
    for seq in seqs:
        diffs = [seq.copy()]
        while any(x != 0 for x in diffs[-1]):
            diffs.append([b - a for a, b in pairwise(diffs[-1])])
        next_diff = 0
        for i in reversed(range(len(diffs) - 1)):
            next_diff = diffs[i][-1] + next_diff
            diffs[i].append(next_diff)
        solution += diffs[0][-1]
    print(solution)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import pairwise

def run(f):
    seqs = [[int(x) for x in s.split()] for s in f.readlines()]

    solution = 0
    for seq in seqs:
        diffs = [list(reversed(seq))] # this is literally the only change
        while any(x != 0 for x in diffs[-1]):
            diffs.append([b - a for a, b in pairwise(diffs[-1])])
        next_diff = 0
        for i in reversed(range(len(diffs) - 1)):
            next_diff = diffs[i][-1] + next_diff
            diffs[i].append(next_diff)
        solution += diffs[0][-1]
    print(solution)

run(stdin)
```


<Divider />

## Day 10 <Spec href="https://adventofcode.com/2023/day/10" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin, setrecursionlimit
from itertools import chain

CONNECTIONS = {
    (-1,  0): {"S", "|", "L", "J"},
    ( 1,  0): {"S", "|", "7", "F"},
    ( 0, -1): {"S", "-", "J", "7"},
    ( 0,  1): {"S", "-", "L", "F"},
}

def run(f):
    pipemap = [s.strip() + "." for s in f.readlines()]
    pipemap.append("."*len(pipemap[0]))

    start = None
    for row, col in enumerate(s.find("S") for s in pipemap):
        if col >= 0:
            start = (row, col)
            break

    dummy = len(pipemap) * len(pipemap[0])
    distances = [[dummy]*len(pipemap[0]) for _ in range(len(pipemap))]

    setrecursionlimit(dummy)
    def dfs(i, j, dist):
        if distances[i][j] <= dist:
            return
        distances[i][j] = dist
        for (ii, jj), symbols in CONNECTIONS.items():
            if (pipemap[i][j] in symbols) and (pipemap[i + ii][j + jj] in CONNECTIONS[(-ii, -jj)]):
                dfs(i + ii, j + jj, dist + 1)
    dfs(*start, 0)
    print(max(x for x in chain(*distances) if (x < dummy)))

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin#, setrecursionlimit
from itertools import chain, product

TILE_CONVERTER = {
    (-1,  0): {"S", "|", "L", "J"},
    ( 1,  0): {"S", "|", "7", "F"},
    ( 0, -1): {"S", "-", "J", "7"},
    ( 0,  1): {"S", "-", "L", "F"},
    ( 0,  0): {"S", "|", "-", "L", "J", "F", "7"},
}

def run(f):
    pipemap = [s.strip() for s in f.readlines()]

    start = None
    for i, j in enumerate(s.find("S") for s in pipemap):
        if j >= 0:
            start = (i, j)
            break

    expanded_map = [["."]*(3*len(pipemap[0])) for _ in range(3 * len(pipemap))]
    for i, row in enumerate(pipemap):
        for j, c in enumerate(row):
            if c != ".":
                (i2, j2) = ((i*3) + 1, (j*3) + 1)
                for (i3, j3), symbols in TILE_CONVERTER.items():
                    if c in symbols:
                        expanded_map[i2 + i3][j2 + j3] = "X"
    start = ((start[0]*3) + 1, (start[1]*3) + 1)

    #setrecursionlimit(len(expanded_map) * len(expanded_map[0]))

    print()
    print("\n".join("".join(x) for x in expanded_map))

    # The code below only works because we know for sure that 'S' passes through
    # just one loop and has no ambiguity. This is confirmed by just inspecting
    # the input file visually.

    # Can't do recursion because we'll literally crash CPython lmao
    def floodfill(i, j, to_replace, new_char):
        stack = [(i, j)]
        while len(stack):
            (i, j) = stack.pop()
            if (i < 0) or (j < 0) \
                    or (i >= len(expanded_map)) or (j >= len(expanded_map[0])) \
                    or expanded_map[i][j] not in to_replace:
                continue
            expanded_map[i][j] = new_char
            for ii, jj in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                stack.append((i + ii, j + jj))
    floodfill(*start, {"X"}, "Y")
    floodfill(0, 0, {".", "X"}, "Y")

    print("\n".join("".join(x) for x in expanded_map))

    solution = 0
    for i, j in product(range(len(pipemap)), range(len(pipemap[0]))):
        solution += expanded_map[(i*3) + 1][(j*3) + 1] != "Y"
    print()
    print(solution)

run(stdin)
```


<Divider />

## Day 11 <Spec href="https://adventofcode.com/2023/day/11" />

### Part 1 BFS Solution

My first solution was a very bad and overly complex approach involving repeated BFS, and takes ages to run.

```py
#!/usr/bin/env python3

from sys import stdin
from heapq import heappush, heappop
from itertools import product

def expand_space(galaxymap):
    (rows, cols) = (len(galaxymap), len(galaxymap[0]))
    for row in reversed(range(rows)):
        if all(c == "." for c in galaxymap[row]):
            galaxymap.insert(row, ["."]*len(galaxymap[0]))
    rows = len(galaxymap)
    for col in reversed(range(cols)):
        if all(galaxymap[row][col] == "." for row in range(rows)):
            for lst in galaxymap:
                lst.insert(col, ".")

def sum_paths(galaxymap, pairs_seen, init):
    pq = [(0, *init)]
    seen = set()
    solution = 0
    while len(pq):
        (dist, i, j) = heappop(pq)
        if ((i, j) in seen) or (i < 0) or (j < 0) \
                or (i >= len(galaxymap)) or (j >= len(galaxymap[0])):
            continue
        seen.add((i, j))
        if (galaxymap[i][j] == "#") and ((init, (i, j)) not in pairs_seen):
            solution += dist
            pairs_seen.add((init, (i, j)))
            pairs_seen.add(((i, j), init))
        for ii, jj in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            heappush(pq, (dist + 1, i + ii, j + jj))
    return solution

def run(f):
    galaxymap = [list(s.strip()) for s in f.readlines()]
    expand_space(galaxymap)

    solution = 0
    pairs_seen = set()
    for i, j in product(range(len(galaxymap)), range(len(galaxymap[0]))):
        if galaxymap[i][j] == "#":
            galaxymap[i][j] = "."
            solution += sum_paths(galaxymap, pairs_seen, (i, j))
            galaxymap[i][j] = "#"
    print(solution)

run(stdin)
```

### Part 1 "Point List" Mathematical Solution

When I read Part 2, I realized the original approach will scale horribly due to the suddenly massively expanded search space. I decided to start by improving Part 1 to validate a new approach.

The new approach simply involves storing a list of galaxy coordinates (`galaxies`) then doing math on each coordinate and each pair of coordinates. Much more elegant, and runs so much faster!

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product, combinations

def run(f):
    galaxymap = [s.strip() for s in f.readlines()]
    galaxies = []
    for i, j in product(range(len(galaxymap)), range(len(galaxymap[0]))):
        if galaxymap[i][j] == "#":
            galaxies.append((i, j))

    empty_rows = [
        i for i in range(len(galaxymap))
        if all(c == "." for c in galaxymap[i])
    ]
    empty_cols = [
        j for j in range(len(galaxymap[0]))
        if all(galaxymap[i][j] == "." for i in range(len(galaxymap)))
    ]

    # Apply expansion
    galaxies = [
        (i + sum(i > ii for ii in empty_rows), j + sum(j > jj for jj in empty_cols))
        for i, j in galaxies
    ]

    print(sum(
        abs(i2 - i1) + abs(j2 - j1)
        for (i1, j1), (i2, j2) in combinations(galaxies, 2)
    ))

run(stdin)
```

### Part 2 Solution

With my faster mathematical solution for Part 1, I made a few modifications to adapt it for Part 2.

I changed the expansion-application to:
```py
# Apply expansion
galaxies = [
    (
        i + (EXPANSION * sum(i > ii for ii in empty_rows)),
        j + (EXPANSION * sum(j > jj for jj in empty_cols)),
    )
    for i, j in galaxies
]
```

and introducing the constant:
```py
EXPANSION = 1000000 - 1
```

The full solution:

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product, combinations

EXPANSION = 1000000 - 1

def run(f):
    galaxymap = [s.strip() for s in f.readlines()]
    galaxies = []
    for i, j in product(range(len(galaxymap)), range(len(galaxymap[0]))):
        if galaxymap[i][j] == "#":
            galaxies.append((i, j))

    empty_rows = [
        i for i in range(len(galaxymap))
        if all(c == "." for c in galaxymap[i])
    ]
    empty_cols = [
        j for j in range(len(galaxymap[0]))
        if all(galaxymap[i][j] == "." for i in range(len(galaxymap)))
    ]

    # Apply expansion
    galaxies = [
        (
            i + (EXPANSION * sum(i > ii for ii in empty_rows)),
            j + (EXPANSION * sum(j > jj for jj in empty_cols)),
        )
        for i, j in galaxies
    ]

    print(sum(
        abs(i2 - i1) + abs(j2 - j1)
        for (i1, j1), (i2, j2) in combinations(galaxies, 2)
    ))

run(stdin)
```


<Divider />

## Day 12 <Spec href="https://adventofcode.com/2023/day/12" />

### Part 1 Brute Force Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

OK = "."
BAD = "#"
UNKNOWN = "?"

def run(f):
    solution = 0
    for s in f.readlines():
        (springs, groups) = s.split()
        springs = list(springs)
        groups = tuple(int(x) for x in groups.split(","))

        num_wildcards = springs.count(UNKNOWN)
        for wildcards in product(OK + BAD, repeat=num_wildcards):
            wildcards = list(wildcards)
            springs2 = springs.copy()
            for i in range(len(springs2)):
                if springs2[i] == UNKNOWN:
                    springs2[i] = wildcards.pop()
            if groups == tuple(len(x) for x in "".join(springs2).replace(".", " ").split()):
                solution += 1
    print(solution)

run(stdin)
```

### Part 1 Backtracking Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

OK = "."
BAD = "#"
UNKNOWN = "?"

def run(f):
    solution = 0
    for s in f.readlines():
        (springs, groups) = s.split()
        #springs = list("?".join([springs]*5))
        #groups = tuple(int(x) for x in groups.split(","))*5
        springs = list(springs) + ["."]
        groups = [0] + [int(x) for x in reversed(groups.split(","))]

        subsolution = 0
        def backtrack(i, is_contiguous_bads):
            nonlocal subsolution
            if i == len(springs):
                if (len(groups) == 1) and (groups[0] == 0):
                    subsolution += 1
                return
            elif springs[i] == UNKNOWN:
                springs[i] = OK
                backtrack(i, is_contiguous_bads)
                springs[i] = BAD
                backtrack(i, is_contiguous_bads)
                springs[i] = UNKNOWN
            elif springs[i] == OK:
                if is_contiguous_bads:
                    if groups[-1] != 0:
                        return
                    groups.pop()
                    if len(groups):
                        backtrack(i + 1, False)
                    groups.append(0)
                else:
                    backtrack(i + 1, False)
            else: # springs[1] == BAD
                if is_contiguous_bads and (groups[-1] == 0):
                    return
                groups[-1] -= 1
                backtrack(i + 1, True)
                groups[-1] += 1
        backtrack(0, False)
        solution += subsolution
    print(solution)

run(stdin)
```

### Part 1 Dynamic Programming Solution

```py
#!/usr/bin/env python3

from sys import stdin
from functools import cache
from itertools import product

OK = "."
BAD = "#"
UNKNOWN = "?"

def run(f):
    solution = 0
    for s in f.readlines():
        (springs, groups) = s.split()
        springs = "." + springs
        groups = tuple(int(x) for x in groups.split(","))

        # Returns number of combinations
        # `i` is the beginning of a subarray in `springs`
        # `j` is the beginning of a subarray in `groups`
        #@cache # runs fast enough without it
        def subproblem(i, j):
            if j == len(groups):
                return all((c != BAD) for c in springs[i:])
            elif len(springs) - i < groups[j] + 1:
                return 0 # not enough room
            elif springs[i] == BAD:
                return 0 # must not connect with previous group
            i += 1
            subsolution = 0
            for i in range(i, len(springs) - groups[j] + 1):
                s = springs[i : i + groups[j]]
                if all(c != OK for c in s):
                    subsolution += subproblem(i + groups[j], j + 1)
                if springs[i] == BAD:
                    break
            return subsolution
        solution += subproblem(0, 0)

    print(solution)

run(stdin)
```

### Part 2 Solution

My Part 2 solution is a modified version of my Part 1 dynamic programming solution.

Instead of:

```py
springs = "." + springs
groups = tuple(int(x) for x in groups.split(","))
```

we instead have:

```py
springs = ["."] + list("?".join([springs]*5))
groups = [int(x) for x in groups.split(",")]*5
```

and I uncomment the `@cache` line since `subproblem()` runs too slow without memoization.

The full solution is thus:

```py
#!/usr/bin/env python3

from sys import stdin
from functools import cache
from itertools import product

OK = "."
BAD = "#"
UNKNOWN = "?"

def run(f):
    solution = 0
    for s in f.readlines():
        (springs, groups) = s.split()
        springs = ["."] + list("?".join([springs]*5))
        groups = [int(x) for x in groups.split(",")]*5

        # Returns number of combinations
        # `i` is the beginning of a subarray in `springs`
        # `j` is the beginning of a subarray in `groups`
        @cache
        def subproblem(i, j):
            if j == len(groups):
                return all((c != BAD) for c in springs[i:])
            elif len(springs) - i < groups[j] + 1:
                return 0 # not enough room
            elif springs[i] == BAD:
                return 0 # must not connect with previous group
            i += 1
            subsolution = 0
            for i in range(i, len(springs) - groups[j] + 1):
                s = springs[i : i + groups[j]]
                if all(c != OK for c in s):
                    subsolution += subproblem(i + groups[j], j + 1)
                if springs[i] == BAD:
                    break
            return subsolution
        solution += subproblem(0, 0)

    print(solution)

run(stdin)
```


<Divider />

## Day 13 <Spec href="https://adventofcode.com/2023/day/13" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

def run(f):
    patterns = [s.split() for s in "".join(f.readlines()).split("\n\n")]

    solution = 0
    for pattern in patterns:
        is_horz_refl = [True]*(len(pattern[0]) - 1)
        is_vert_refl = [True]*(len(pattern) - 1)
        for i, j in product(range(len(pattern)), range(len(pattern[0]))):
            c = pattern[i][j]
            # check horizontal reflections
            for j_midline in range(j, len(pattern[0])):
                j_refl = j_midline + (j_midline - j) + 1
                if j_refl >= len(pattern[0]):
                    break
                elif c != pattern[i][j_refl]:
                    is_horz_refl[j_midline] = False
            # check vertical reflections
            for i_midline in range(i, len(pattern)):
                i_refl = i_midline + (i_midline - i) + 1
                if i_refl >= len(pattern):
                    break
                elif c != pattern[i_refl][j]:
                    is_vert_refl[i_midline] = False
        solution += sum(i + 1 for i, v in enumerate(is_horz_refl) if v)
        solution += sum(i + 1 for i, v in enumerate(is_vert_refl) if v) * 100
    print(solution)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

def run(f):
    patterns = [s.split() for s in "".join(f.readlines()).split("\n\n")]

    solution = 0
    for pattern in patterns:
        horz_refl_breakages = [0]*(len(pattern[0]) - 1)
        vert_refl_breakages = [0]*(len(pattern) - 1)
        for i, j in product(range(len(pattern)), range(len(pattern[0]))):
            c = pattern[i][j]
            # check horizontal reflections
            for j_midline in range(j, len(pattern[0])):
                j_refl = j_midline + (j_midline - j) + 1
                if j_refl >= len(pattern[0]):
                    break
                elif c != pattern[i][j_refl]:
                    horz_refl_breakages[j_midline] += 1
            # check vertical reflections
            for i_midline in range(i, len(pattern)):
                i_refl = i_midline + (i_midline - i) + 1
                if i_refl >= len(pattern):
                    break
                elif c != pattern[i_refl][j]:
                    vert_refl_breakages[i_midline] += 1
        solution += sum(i + 1 for i, v in enumerate(horz_refl_breakages) if v == 1)
        solution += sum(i + 1 for i, v in enumerate(vert_refl_breakages) if v == 1) * 100
    print(solution)

run(stdin)
```


<Divider />

## Day 14 <Spec href="https://adventofcode.com/2023/day/14" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin

def run(f):
    rockmap = [s.strip() for s in f.readlines()]

    solution = 0
    for j in range(len(rockmap[0])):
        empty_i = 0
        for i in range(len(rockmap)):
            c = rockmap[i][j]
            if c == "#":
                empty_i = i + 1
            elif c == "O":
                solution += len(rockmap) - empty_i
                empty_i += 1
    print(solution)

run(stdin)
```

### Part 2 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import chain, product

TARGET_ITERATIONS = 1000000000

def rotate_grid(rockmap):
    new_map = []
    for j in range(len(rockmap[0])):
        new_row = []
        new_map.append(new_row)
        for i in reversed(range(len(rockmap))):
            new_row.append(rockmap[i][j])
    return new_map

def push_north(rockmap):
    for j in range(len(rockmap[0])):
        empty_i = 0
        for i in range(len(rockmap)):
            c = rockmap[i][j]
            if c == "#":
                empty_i = i + 1
            elif c == "O":
                rockmap[i][j] = "."
                rockmap[empty_i][j] = "O"
                empty_i += 1

def calculate_load(rockmap):
    return sum(
        len(rockmap) - i
        for i, j in product(range(len(rockmap)), range(len(rockmap[0])))
        if rockmap[i][j] == "O"
    )

def run(f):
    rockmap = [list(s.strip()) for s in f.readlines()]
    latest_i = {} # {stringified map: latest iteration}
    history = [] # loads

    (dist, dist_repeats) = (-1, 0)
    end_iteration = None
    for i in range(TARGET_ITERATIONS):
        for _ in range(4):
            push_north(rockmap)
            rockmap = rotate_grid(rockmap)
        s = "".join(chain(*rockmap))
        if (s in latest_i) and (i - latest_i[s] == dist):
            dist_repeats += 1
        else:
            dist_repeats = 0
        history.append(calculate_load(rockmap))
        if (dist_repeats != 0) and (dist_repeats == dist):
            end_iteration = i
            break
        if s in latest_i:
            dist = i - latest_i[s]
        latest_i[s] = i

    # we assume we actually do find a repeat
    # (not going to bother dealing with the edge case of no periodicity)
    if end_iteration is None:
        raise RuntimeError()

    history = history[-dist:] # just get the repeated section
    base = end_iteration + 1
    #print(history)
    print(history[(TARGET_ITERATIONS - base - 1) % len(history)])

run(stdin)
```


<Divider />

## Day 15 <Spec href="https://adventofcode.com/2023/day/15" />

### Part 1 Solution

```py
#!/usr/bin/env python3

from sys import stdin
from itertools import product

def run(f):
    strs = f.readlines()[0].strip().split(",")

    solution = 0
    for s in strs:
        cur_hash = 0
        for c in s:
            cur_hash = ((cur_hash + ord(c)) * 17) % 256
        solution += cur_hash
    print(solution)

run(stdin)
```

### Part 2 Solution

Such a pain in the ass verbose problem specification in terms of trying to parse out how the algorithm is supposed to work. At least Part 1 was super-simple and easy to skim. Part 2 has relatively many moving parts with the different parts spread out across the problem specification text. The question was obviously designed more as a reading comprehension problem than anything else really.

Along the way, I made two notable misunderstandings of the problem specification:

- I originally thought each box held at most one lens. This led to misunderstanding the functionality of the `-` operation character, particularly the phrase *"move any remaining lenses as far forward in the box as they can go without changing their order"*. I assumed I was meant to shift the lenses to different boxes.
- I originally obtained the box numbers by running the "HASH algorithm" over the entire command string (e.g. running the HASH algorithm over all four characters of `rn=1`) when it should only be run over the "label" portion of the command string (e.g. for `rn=1`, the label is `rn`).

My final solution after resolving all misunderstandings:

```py
#!/usr/bin/env python3

from sys import stdin

def get_box_num(s):
    boxnum = 0
    for c in s:
        boxnum = ((boxnum + ord(c)) * 17) % 256
    return boxnum

def run(f):
    strs = f.readlines()[0].strip().split(",")

    boxes = [[] for _ in range(256)] # [[[label, focal length], ...], ...]
    for s in strs:
        if "-" in s:
            label = s[:-1]
            box = boxes[get_box_num(label)]
            box[:] = [x for x in box if (x[0] != label)]
        else:
            (label, focal_len) = s.split("=")
            box = boxes[get_box_num(label)]
            for tup in box:
                if tup[0] == label:
                    tup[1] = focal_len
                    break
            else:
                box.append([label, focal_len])

    print(sum(
        ((1 + boxnum) * sum(
            (i + 1) * int(focal_len) for i, (label, focal_len) in enumerate(box)
        ))
        for boxnum, box in enumerate(boxes)
    ))

run(stdin)
```


<Divider />

## Day 16 <Spec href="https://adventofcode.com/2023/day/16" />

### Part 1 Solution

I went for a DFS solution, tracking both position (`i` and `j`) and facing direction unit vectors (`i_dir` and `j_dir`) at each step of the DFS.

We prevent infinite loops by *conceptually* keeping a set of `(i, j, i_dir, j_dir)` tuples. The actual implementation is a 2D grid of sets called `seen`, where the grid indices are `i` and `j` while each set stores the unit direction vectors that have passed through the grid location.

The DFS starts with `travel(0, 0, 0, 1)`, meaning we start at the `i=0` and `j=0` (i.e. the top-left corner) and travelling in the direction of `i_dir=0` and `j_dir=1` (i.e. we are travelling in the positive-j direction).

```py
#!/usr/bin/env python3

from sys import stdin, setrecursionlimit
from itertools import chain

def run(f):
    grid = [s.strip() for s in f.readlines()]
    setrecursionlimit(len(grid) * len(grid[0]))

    # grid of sets of unit directional vectors (i, j)
    seen = [[set() for _ in range(len(grid[0]))] for _ in range(len(grid))]

    def travel(i, j, i_dir, j_dir):
        if (i < 0) or (i >= len(grid)) \
                or (j < 0) or (j >= len(grid[0])) \
                or (i_dir, j_dir) in seen[i][j]:
            return
        seen[i][j].add((i_dir, j_dir))
        c = grid[i][j]
        if c == ".":
            travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "|":
            if j_dir:
                travel(i + 1, j,  1, 0)
                travel(i - 1, j, -1, 0)
            else:
                travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "-":
            if i_dir:
                travel(i, j + 1, 0,  1)
                travel(i, j - 1, 0, -1)
            else:
                travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "/":
            travel(i - j_dir, j - i_dir, -j_dir, -i_dir)
        else: # "\"
            travel(i + j_dir, j + i_dir, j_dir, i_dir)
    travel(0, 0, 0, 1)

    print(sum(len(x) > 0 for x in chain(*seen)))

run(stdin)
```

I didn't actually write out those `elif c = "/":` and `else:` branches like that the first time around. I originally wrote it out explicitly:

```py
        elif c == "/":
            if j_dir == 1:
                travel(i - 1, j, -1, 0)
            elif j_dir == -1:
                travel(i + 1, j, 1, 0)
            elif i_dir == 1:
                travel(i, j - 1, 0, -1)
            else:
                travel(i, j + 1, 0, 1)
        else: # "\"
            if j_dir == 1:
                travel(i + 1, j, +1, 0)
            elif j_dir == -1:
                travel(i - 1, j, -1, 0)
            elif i_dir == 1:
                travel(i, j + 1, 0, 1)
            else:
                travel(i, j - 1, 0, -1)
```

Only after verifying I got the right answer did I refactor to the final version before moving on to Part 2.

### Part 2 Solution

I refactored the Part 1 functionality into a new function `calculate_coverage()` before running `calculate_coverage()` on every possible entrypoint into the grid to get the final answer.

```py
#!/usr/bin/env python3

from sys import stdin, setrecursionlimit
from itertools import chain

def calculate_coverage(grid, _i, _j, _i_dir, _j_dir):
    # grid of sets of unit directional vectors (i, j)
    seen = [[set() for _ in range(len(grid[0]))] for _ in range(len(grid))]

    def travel(i, j, i_dir, j_dir):
        if (i < 0) or (i >= len(grid)) \
                or (j < 0) or (j >= len(grid[0])) \
                or (i_dir, j_dir) in seen[i][j]:
            return
        seen[i][j].add((i_dir, j_dir))
        c = grid[i][j]
        if c == ".":
            travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "|":
            if j_dir:
                travel(i + 1, j,  1, 0)
                travel(i - 1, j, -1, 0)
            else:
                travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "-":
            if i_dir:
                travel(i, j + 1, 0,  1)
                travel(i, j - 1, 0, -1)
            else:
                travel(i + i_dir, j + j_dir, i_dir, j_dir)
        elif c == "/":
            travel(i - j_dir, j - i_dir, -j_dir, -i_dir)
        else: # "\"
            travel(i + j_dir, j + i_dir, j_dir, i_dir)
    travel(_i, _j, _i_dir, _j_dir)
    return sum(len(x) > 0 for x in chain(*seen))

def run(f):
    grid = [s.strip() for s in f.readlines()]
    setrecursionlimit(len(grid) * len(grid[0]))

    solution = 0
    for i in range(len(grid)): # left edge
        solution = max(solution, calculate_coverage(grid, i, 0, 0, 1))
    for i in range(len(grid)): # right edge
        solution = max(solution, calculate_coverage(grid, i, len(grid[0]) - 1, 0, -1))
    for j in range(len(grid[0])): # top edge
        solution = max(solution, calculate_coverage(grid, 0, j, 1, 0))
    for j in range(len(grid[0])): # bottom edge
        solution = max(solution, calculate_coverage(grid, len(grid) - 1, j, -1, 0))
    print(solution)

run(stdin)
```


<Divider />

## Day 17 <Spec href="https://adventofcode.com/2023/day/17" />

*TODO*


<Divider />

## Day 18 <Spec href="https://adventofcode.com/2023/day/18" />

*TODO*


<Divider />

## Day 19 <Spec href="https://adventofcode.com/2023/day/19" />

*TODO*


<Divider />

## Day 20 <Spec href="https://adventofcode.com/2023/day/20" />

*TODO*


<Divider />

## Day 21 <Spec href="https://adventofcode.com/2023/day/21" />

*TODO*


<Divider />

## Day 22 <Spec href="https://adventofcode.com/2023/day/22" />

*TODO*


<Divider />

## Day 23 <Spec href="https://adventofcode.com/2023/day/23" />

*TODO*


<Divider />

## Day 24 <Spec href="https://adventofcode.com/2023/day/24" />

*TODO*


<Divider />

## Day 25 <Spec href="https://adventofcode.com/2023/day/25" />

*TODO*

