---
layout: "@layouts/MDLayout.astro"
title: Dynamic Programming - CSES Problem Set Solutions
description: My solutions and thoughts for the CSES problem set!
keywords: ["cp", "competitive programming", "leetcode", "algorithms", "data structures"]
---

import AlignLatex from "@components/latex/AlignLatex";
import DisplayLatex from "@components/latex/DisplayLatex";
import Eqref from "@components/latex/Eqref";
import GatherLatex from "@components/latex/GatherLatex";
import Eq from "@components/latex/Eq";
import Trl from "@components/latex/TableRowLatex";
import Trhl from "@components/latex/TableRowHLatex";

import FigImg from "@components/figures/FigImg";
import FiguresBlock from "@components/figures/FiguresBlock";
import Fig from "@components/figures/Fig";

import Code from "@components/Code.astro";
import SpoilerBlock from "@components/SpoilerBlock.astro";
import Todo from "@components/Todo";

import Spec from "./../_shared.Spec.astro"; //_
import Intro from "./_common.intro.astro"; //_

import DArr from "./_common.DArr.astro"; //_
import UArr from "./_common.UArr.astro"; //_
import LArr from "./_common.LArr.astro"; //_
import RArr from "./_common.RArr.astro"; //_
import DLArr from "./_common.DLArr.astro"; //_
import URArr from "./_common.URArr.astro"; //_


<Intro />


## Dice Combinations <Spec href="https://cses.fi/problemset/task/1633" cdate="2024-03-13" />

The subproblem is simply a Fibonacci-esque recursive function:

<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_n = F_{n-1} + F_{n-2} + F_{n-3} + F_{n-4} + F_{n-5} + F_{n-6}
    \quad\text{for}\quad n > 0
" />

With DP, this runs in <Eq code="O(n)" /> time. Considering how the input bounds set <Eq code="n \le {10}^6" />, a test case can in theory run a hotspot <Eq code="6 \times {10}^6" /> times.

We choose <Eq code="F_{n-1}" /> through to <Eq code="F_{n-6}" /> since we know each dice roll has to be integers 1-6.

My first attempt was a top-down implementation, though it comes to no surprise that it causes runtime errors (presumably stack overflow):

import SolDiceCombinations01 from "./_solutions.dynamic-programming/dice-combinations--01-fail-stackoverflow.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (Stack Overflow)">
    <Code code={SolDiceCombinations01} lang="py" />
</SpoilerBlock>

Setting a higher `setrecursionlimit` fixed the runtime errors, but instead TLE's. Not too surprising. Implementation:

import SolDiceCombinations02 from "./_solutions.dynamic-programming/dice-combinations--02-fail-tle.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (TLE)">
    <Code code={SolDiceCombinations02} lang="py" />
</SpoilerBlock>

Switching to a simple top-down approach passed all tests (worst-case runtime in CPython and PyPy3 was 1.00s and 0.22s, respectively):

import SolDiceCombinations03 from "./_solutions.dynamic-programming/dice-combinations--03-pass.py?raw" //_

<Code code={SolDiceCombinations03} lang="py" />

Switching to only storing a fixed-size window reduced the worst test case runtimes to 0.44s and 0.13s (CPython and PyPy3, respectively):

import SolDiceCombinations04 from "./_solutions.dynamic-programming/dice-combinations--04-pass.py?raw" //_

<Code code={SolDiceCombinations04} lang="py" />

Making it so we don't re-add all six elements of `tab` anymore turned out to perform worse:

import SolDiceCombinations05 from "./_solutions.dynamic-programming/dice-combinations--05-pass.py?raw" //_

<Code code={SolDiceCombinations05} lang="py" />


## Minimizing Coins <Spec href="https://cses.fi/problemset/task/1634" cdate="2024-03-31" />

The first subproblem that comes to mind is, for every integer from <Eq code="0" /> to <Eq code="x" />, we find the fewest number of coins possible. Runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = \infty
    \qquad
    F_0 = 0
    \\
    F_x = \min_{c \in C}\parens{
        F_{x - c}
    } + 1
    \quad\text{for}\quad x > 0
" />

Considering how the input bounds set <Eq code="n \le 100" /> and <Eq code="x \le {10}^6" />, a test case can in theory run a hotspot <Eq code="{10}^8" /> times. Assuming a similar style of implementation to my first Dice Combinations passed solution which had a worst runtime of 0.22s, it doesn't sound like Minimizing Coins in Python should pass since we get a hotspot running at least 10x as many times.

For fun, we start with a Python top-down solution, as well as bottom-up, and I also tried an optimization that precomputes some trivial table entries. The logic appears correct, but they TLE as expected:

import SolMinimizingCoins01 from "./_solutions.dynamic-programming/minimizing-coins--01-fail-tle-topdown.py?raw" //_
import SolMinimizingCoins02 from "./_solutions.dynamic-programming/minimizing-coins--02-fail-tle-bottomup.py?raw" //_
import SolMinimizingCoins03 from "./_solutions.dynamic-programming/minimizing-coins--03-fail-tle-added-precomputes.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolMinimizingCoins01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution (TLE)">
    <Code code={SolMinimizingCoins02} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution With Optimization (TLE)">
    <Code code={SolMinimizingCoins03} lang="py" />
</SpoilerBlock>

Implementing the bottom-up approach in C++ passed all tests (with a longest runtime of 0.15s):

import SolMinimizingCoins05 from "./_solutions.dynamic-programming/minimizing-coins--05-pass-bottomup.cpp?raw" //_

<Code code={SolMinimizingCoins05} lang="cpp" />


## Coin Combinations I <Spec href="https://cses.fi/problemset/task/1635" cdate="2024-04-01" />

Different orderings of the same set of coins count as different combinations, which makes subproblem selection easier. My chosen subproblem is to find the number of combinations for each possible target sum <Eq code="0" /> to <Eq code="x" />. For <Eq code="n" /> coins, the runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_x = \sum_{c \in C}{
        F_{x - c}
    }
    \quad\text{for}\quad x > 0
" />

Input bounds are similar to Minimizing Coins, so a hotspot possibly runs <Eq code="{10}^8" /> times, and is similarly unlikely to pass using Python.

But let's write a top-down Python implementation anyway! As expected, it TLE's:

import SolCoinCombinationsI01 from "./_solutions.dynamic-programming/coin-combinations-i--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolCoinCombinationsI01} lang="py" />
</SpoilerBlock>

Implementing bottom-up in C++ passes all tests:

import SolCoinCombinationsI02 from "./_solutions.dynamic-programming/coin-combinations-i--02-pass-bottomup.cpp?raw" //_

<Code code={SolCoinCombinationsI02} lang="cpp" />


## Coin Combinations II <Spec href="https://cses.fi/problemset/task/1636" cdate="2024-04-01" />

If we used the strategy from Coin Combinations I, we run into the problem of needing to avoid double-counting combinations. To deal with this, maybe we need a two-dimensional table: one dimension for coin value, and another dimension for coin sum. The following subproblem comes to mind, which may naively run in <Eq code="O(x^2 n)" /> time:

<DisplayLatex code="
    C = \braces{c_1, \dots, c_n} = \text{set of all coin values}
" />
<GatherLatex code="
    F\brackets{0, x} =
    \begin{cases}
        1 \quad& x = 0 \\
        0 \quad& \text{otherwise}
    \end{cases}
    \\
    F\brackets{i, x} =
    \sum_{j = 0}^{\infty}{
        F\brackets{i - 1, x - j c_i}
    }
    \quad\text{for}\quad i > 0
" />

I say "naively" because there may be a way to cut that runtime to <Eq code="O(xn)" /> with a clever optimization. I'll get to my idea for that later.

I am very certain <Eq code="O(x^2 n)" /> will TLE, but I made a top-down Python implementation anyway just for fun. It passes some tests, but TLE's everything else. Good to know that we're not getting any wrong answers! Implementation:

import SolCoinCombinationsII01 from "./_solutions.dynamic-programming/coin-combinations-ii--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolCoinCombinationsII01} lang="py" />
</SpoilerBlock>

Let's have a look at my <Eq code="O(xn)" /> idea now. I'd use the same subproblem and implement it bottom-up, but I'd fill up the table with the help of an accumulator, which should let me avoid doing the whole <Eq code="\sum_{j=0}^{\infty}" /> summation in <Eq code="O(x)" /> time each time. Instead, the accumulator calculates this summation in <Eq code="O(1)" /> on average.

It's probably easier to just see how this works in code.

My first implementation works perfectly fine on my computer, but causes weird `RUNTIME ERROR`s on some test cases when I submit to CSES. I have a screenshot included in the spoiler block below. My code provides the correct answers when I run them on my computer, and none of them TLE, so... I'm not sure what's going on. Full implementation:

import SolCoinCombinationsII02 from "./_solutions.dynamic-programming/coin-combinations-ii--02-fail-runtimeerr-works-on-my-machine.cpp?raw" //_
import SolCoinCombinationsII02TestResults from "./_images.dynamic-programming/coin-combinations-ii--02-test-results.png" //_

<SpoilerBlock buttonLabel="Failed C++ Bottom-Up Solution, Weird Runtime Error?">
    <Code code={SolCoinCombinationsII02} lang="cpp" />
    <FiguresBlock>
        <FigImg src={SolCoinCombinationsII02TestResults} alt="Submission test results for my first C++ optimized bottom-up solution." />
    </FiguresBlock>
</SpoilerBlock>

*(If anyone knows why I'm getting `RUNTIME ERROR`, I'd love to know!)*

I improved on this solution by changing to a more space-efficient 1D vector, which did pass all test cases:

import SolCoinCombinationsII04 from "./_solutions.dynamic-programming/coin-combinations-ii--04-pass-bottomup-optimized.cpp?raw" //_

<Code code={SolCoinCombinationsII04} lang="cpp" />

<Todo>Were the `RUNTIME ERROR`s to do with the way I implemented the 2D table as 2D vectors?</Todo>


## Removing Digits <Spec href="https://cses.fi/problemset/task/1637" cdate="2024-04-03" />

The first subproblem that comes to mind finds the minimum number of steps for each number from <Eq code="0" /> to <Eq code="n" />. It runs in <Eq code="O(n \log_{10} n)" /> since there are <Eq code="O(n)" /> entries in the 1D table, and at each entry, you check every decimal digit (which is <Eq code="O(\log_{10} n)" />). The subproblem written out:

<DisplayLatex code="
    n = \text{input number}
" />
<GatherLatex code="
    F_0 = 0
    \\
    F_n = \min_{d \in D\parens{n}}\parens{
        F_{n - d}
    } + 1
    \quad\text{for}\quad x > 0
" />
<DisplayLatex code="
    \text{where } D\parens{n} = \text{all decimal digits of } n \text{ except } 0
" />

For fun, I started with a Python top-down implementation, which TLE's as expected, but also didn't give any wrong answers:

import SolRemovingDigits01 from "./_solutions.dynamic-programming/removing-digits--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolRemovingDigits01} lang="py" />
</SpoilerBlock>

My bottom-up implementation in Python passed all tests:

import SolRemovingDigits02 from "./_solutions.dynamic-programming/removing-digits--02-pass-bottomup.py?raw" //_

<Code code={SolRemovingDigits02} lang="py" />

It also passed all tests when I used string conversion to get the digits:

import SolRemovingDigits03 from "./_solutions.dynamic-programming/removing-digits--03-pass-bottomup-strconv.py?raw" //_

<Code code={SolRemovingDigits03} lang="py" />


## Grid Paths <Spec href="https://cses.fi/problemset/task/1638" cdate="2024-04-03" />

The fact that paths can only move in one direction makes this problem so much easier since you don't have to worry about paths backtracking. The first subproblem that comes to mind is to, at each cell in the grid, you add up how many paths can come from above with how many paths can come from the left. It runs in <Eq code="O(n^2)" /> (or more usefully, <Eq code="O(N)" /> for <Eq code="N" /> total cells in the grid):

<GatherLatex code="
    G\brackets{i, j} \in \braces{\texttt{EMPTY}, \texttt{TRAP}}
" />
<GatherLatex code="
    F\brackets{i, j} =
    \begin{cases}
        0
        \quad&
            \parens{i < 0}
            \lor \parens{j < 0}
            \lor \parens{G\brackets{i, j} = \texttt{TRAP}}
        \\
        F\brackets{i - 1, j} + F\brackets{i, j - 1}
        \quad& \text{otherwise}
    \end{cases}
" />

Surprisingly, a Python top-down implementation using `@functools.cache` (and running on CPython3) almost passed, but TLE'd on only 2 out of the 15 test cases:

import SolGridPaths01 from "./_solutions.dynamic-programming/grid-paths--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolGridPaths01} lang="py" />
</SpoilerBlock>

It took 0.99s for one of the passed <Eq code="1000 \times 1000" /> test cases, which indicates to me that not only should Python be feasible, but Python top-down is likely to be feasible as well if I can lower the overhead. And indeed it did pass, although the code isn't quite that nice since I'm implementing my own memoization:

import SolGridPaths03 from "./_solutions.dynamic-programming/grid-paths--03-pass-topdown.py?raw" //_

<Code code={SolGridPaths03} lang="py" />

My bottom-up implementation is also a bit obscured since I used some tricks to avoid adding if-statements to the main loop (and therefore unnecessary overhead). Here, I pad the grid with an extra row and column (on the top and left sides) so that we automatically get zeroes for paths that try to come from outside of the grid. Implementation:

import SolGridPaths04 from "./_solutions.dynamic-programming/grid-paths--04-pass-bottomup.py?raw" //_

<Code code={SolGridPaths04} lang="py" />


## Book Shop <Spec href="https://cses.fi/problemset/task/1158" cdate="2024-04-03" />

This is the classic *0-1 knapsack problem*, which I've already done a very detailed writeup on ([here](http://localhost:3000/c/notes/dsa/dynamic-programming/#0-1-knapsack-problem)), so unfortunately, I've already been very thoroughly spoiled on this problem.

The subproblem has two dimensions: "the current book", and current max cost of currently selected books (from <Eq code="0" /> to <Eq code="x" />). At each "current book" (and corresponding current max cost), we find out what the best possible number of pages is whether or not we purchase the current book. It runs in <Eq code="O(nx)" />:

<DisplayLatex code="
    \braces{\parens{c_1, p_1}, \dots, \parens{c_n, p_n}} = \text{costs and number of pages}
" />
<DisplayLatex code="
    F\brackets{i, x} =
    \begin{cases}
        {\displaystyle
            \vphantom{\sum}
            -\infty
        }
        \quad& x < 0
        \\
        {\displaystyle
            \vphantom{\sum}
            0
        }
        \quad& \parens{x \ge 0} \land \parens{i = 0}
        \\
        {\displaystyle
            \max\parens{
                \vphantom{\sum}
                F\brackets{i - 1, x - c_i} + p_i,
                F\brackets{i - 1, x}
            }
        }
        \quad& \text{otherwise}
    \end{cases}
" />

My first top-down Python implementation TLE'd as I expected:

import SolBookShop01 from "./_solutions.dynamic-programming/book-shop--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolBookShop01} lang="py" />
</SpoilerBlock>

Implementing bottom-up Python with a full <Eq code="O(nx)" />-sized table caused many `RUNTIME ERROR` results, but they otherwise gave me correct answers on my computer (albeit very slowly):

import SolBookShop02 from "./_solutions.dynamic-programming/book-shop--02-fail-runtimeerr-works-on-my-machine.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution With Full Table (TLE)">
    <Code code={SolBookShop02} lang="py" />
</SpoilerBlock>

My more optimized bottom-up Python implementation that instead uses a <Eq code="O(x)" />-sized table TLE'd, even on PyPy3:

import SolBookShop04 from "./_solutions.dynamic-programming/book-shop--04-fail-tle-bottomup.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution With Smaller Table (TLE)">
    <Code code={SolBookShop04} lang="py" />
</SpoilerBlock>

Reimplementing this optimized bottom-up solution in C++ passes all tests with a worst runtime of only 0.15s:

import SolBookShop05 from "./_solutions.dynamic-programming/book-shop--05-pass-bottomup.cpp?raw" //_

<Code code={SolBookShop05} lang="cpp" />


## Array Description <Spec href="https://cses.fi/problemset/task/1746/" cdate="2024-04-03" />

The first subproblem that comes to mind has two dimensions: current position in the array description, and candidate value for the position. At each position, we simply count the number of possible "paths" coming from the start of the array. The runtime is <Eq code="O(nm)" />.

What I mean by "path" is, let's pretend that the beginning of the array (index 0) is known to be the value 5. From index 0, we might be able to "walk" to three different positions in index 1: \{index 1, value 4\}, \{index 1, value 5\}, and \{index 1, value 6\}. We say that there are valid "paths" from the beginning of the array to these three positions. These paths may extend all the way through the array, constrained by the known array values.

<p><Todo>I should illustrate what I mean by a "path".</Todo></p>

The subproblem written out:

<GatherLatex code="
    m = \text{upper bound for array values}
    \\
    \braces{a_0, \dots, a_{n - 1}} = \text{the array description}
" />
<DisplayLatex code="
    F\brackets{i, v} =
    \begin{cases}
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            1
        \end{array}
        \quad& \parens{0 < v \le m} \land \parens{a_0 \in \braces{0, v}} \land \parens{i = 0}
        \\
        \displaystyle
        \begin{array}{l}
            F\brackets{i - 1, v} \\
            \quad + F\brackets{i - 1, v - 1} \\
            \quad + F\brackets{i - 1, v + 1}
        \end{array}
        \quad& \parens{0 < v \le m} \land \parens{a_0 \in \braces{0, v}} \land \parens{i > 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            0
        \end{array}
        \quad& \text{otherwise}
    \end{cases}
" />
<DisplayLatex code="
    \text{solution} = \sum_{v = 1}^m F\brackets{n - 1, v}
" />

A top-down implementation in Python TLE'd, but otherwise gave no wrong answers:

import SolArrayDescription01 from "./_solutions.dynamic-programming/array-description--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolArrayDescription01} lang="py" />
</SpoilerBlock>

Changing to a bottom-up with a full <Eq code="O(nm)" /> sized table passed all tests with a PyPy3 worst-case runtime of 0.33s:

import SolArrayDescription02 from "./_solutions.dynamic-programming/array-description--02-pass-bottomup.py?raw" //_

<Code code={SolArrayDescription02} lang="py" />

Improving on the bottom-up solution by switching to an <Eq code="O(m)" /> table also passed, but now with a PyPy3 worst-case runtime of 0.13s:

import SolArrayDescription03 from "./_solutions.dynamic-programming/array-description--03-pass-bottomup-optimized.py?raw" //_

<SpoilerBlock buttonLabel="Alternative Python Bottom-Up Solution With O(m) Table (TLE)">
    <Code code={SolArrayDescription03} lang="py" />
</SpoilerBlock>


## Counting Towers <Spec href="https://cses.fi/problemset/task/2413" cdate="2024-04-04" />

This one's a hard one! But also a fun one! Let's start by enumerating some simple examples to get a feel for how this works:

```
n=1  --> solution=2

AB  AA
```
```
n=2  --> solution=8

CD       AB  BA  AB
AB       AC  CA  AB

AA       AA  BC  AA
AA       BC  AA  BB
```

The first idea that comes to mind is to try a subproblem with two dimensions: the <Eq code="x" /> and <Eq code="y" /> coordinates of the top-right of the tower, where the bottom-left corner is at coordinates <Eq code="\parens{0, 0}" />. Let's call this subproblem <Eq code="F\brackets{x, y}" />. <Eq code="x" /> is the column index while <Eq code="y" /> is the row index. However, it doesn't work well:

<SpoilerBlock buttonLabel="explanation of this failed idea">
We expect <Eq code="F\brackets{0, 0} = 1" /> since the only possible tower is a single <Eq code="1 \times 1" /> block.

We expect <Eq code="F\brackets{1, 0} = 2" /> since it's the <Eq code="n = 1" /> case. Perhaps we should try calculating every possible block that contains coordinates <Eq code="\parens{1, 0}" />? Let's try sketching it out:

```
(Apologies if this is hard to understand, but hopefully it'll be clear
by the time you also see the F[1, 1] example.)

There are two cases of blocks that contain (1, 0):

    ?A   AA

The first case can only be the tower:

    BA

Therefore, the first case shows one possible tower.

The second case is trivially just the entire tower being a single block,
therefore it also shows only one tower.

Therefore, there are two possible towers for F[1, 0].
```

Let's also try <Eq code="F\brackets{1, 1}" />, which is the <Eq code="n = 2" /> case:

```
There are four cases to consider:

    ?A   AA   ?A   AA
    ??   ??   ?A   AA

Case 1 has 3 combinations:

    BA   BA  BA
    CD   BD  DD

Case 2 has 2 combinations:

    AA   AA
    BC   BB

Case 3 has 2 combinations:

    BA   BA
    CA   BA

Case 4 trivially only has the one combination:

    AA
    AA

Therefore, there are 8 possible towers for F[1, 1].
```

And let's also try <Eq code="F\brackets{1, 2}" />:

```
n=3

case 1 has 1 combination:
XX
XX
XX

case 2 has 2 combinations:
XX       XX XX
XX  -->  XX XX
??       AB AA

case 3 has 8 combinations:
XX       XX   XX XX XX   XX   XX XX XX   (These are all similar
??  -->  CD   AB BA AB   AA   AA BC AA   to n=1.)
??       AB   AC CA AB   AA   BC AA BB

case 4 has 4 combinations:
?X       AX AX CX AX
?X  -->  BX AX AX AX
?X       CX CX AX AX

case 5 has 6 combinations:
?X       AX   AX BX BX   AX   AX
?X  -->  BX   AX AX CX   AX   AX
??       CD   CD AD AA   BB   AB

case 6 has 12 combinations:
?X       YX   YX YX YX   YX   YX YX YX   (This row is all
??  -->  CD   AB BA AB   AA   AA BC AA   similar to case 3.)
??       AB   AC CA AB   AA   BC AA BB

         YX YX YX        YX
         YD YB YA        YX
         AB AA BA        YA


Therefore, there are 33 possible towers for F[1, 2].
```

So how might we calculate each cases of <Eq code="F\brackets{1, 2}" />?

The first thing that comes to mind is to try breaking it down into three calculations. Let's try Case 6 as an example. Case 6 might be seen as a combination of three cases: <Eq code="F\brackets{0, 2}" />, <Eq code="F\brackets{1, 1}" />, and <Eq code="F\brackets{0, 1}" />:

```
F[0, 2]  |  F[1, 1]  |  F[0, 1]
         |           |
   ?     |           |
   ?     |     ??    |     ?
   ?     |     ??    |     ?
         |           |
4 combs. | 8 combs.  | 2 combs.
```

<AlignLatex code="
    F\brackets{0, 2} + F\brackets{1, 1} - F\brackets{0, 1}
    &= 4 + 8 - 2
    \\
    &= 10 \ne 12
" />

I also tried out:

<AlignLatex code="
    F\brackets{0, 2} + F\brackets{1, 1}
    &= 4 + 8
    \\
    &= 12
" />

But this doesn't generalize well. For example:

```
The case to consider:

    ?A
    ??

This would be F[0, 1] + F[1, 0] = 2 + 2 = 4

But we have already seen that this case should only have 3 combinations.
```

I'm still not sure how to make this idea work, so let's move on to something different.
</SpoilerBlock>

import SolCountingTowers01 from "./_solutions.dynamic-programming/counting-towers--01-fail-wrong-answer-example.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (Wrong Answers)">
    <Code code={SolCountingTowers01} lang="py" />
</SpoilerBlock>

The next idea that comes to mind is also two dimensions, with one dimension for height of the left side, and one for the right side. It naively sounds like it should perform poorly at <Eq code="O(n^2)" /> where <Eq code="n \le {10}^6" />, but maybe we can apply the same trick as Coin Combinations II where we use an accumulator?

Let's start by visualizing what's going on then formalizing the subproblem:

```
Case 1: Both sides same level
        We arbitrarily pick the top-right block to be fixed.

   F[3,3] = F[3,2] + F[3,1] + F[3,0] + F[2,2] + F[1,1] + F[0,0]

     ??       ?        ?        ?
     ??   =   ??   +   ?    +   ?    +   ??   +        +
     ??       ??       ??       ?        ??       ??

Case 2: Left side is taller
        We pick the tallest block to be fixed.

   F[3,2] = F[2,2] + F[1,2] + F[0,2]

     ?
     ??   =   ??   +    ?   +    ?
     ??       ??       ??        ?

Case 3: Right side is taller
        We just mirror it.

   F[2,3] = F[3,2]

      ?       ?
     ??   =   ??
     ??       ??
```

Writing out the subproblem:

<DisplayLatex code="
    F\brackets{a, b} =
    \begin{cases}
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            1
        \end{array}
        \quad& \parens{a = b = 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            \displaystyle
            \sum_{x = 0}^{b - 1}\parens{\vphantom{\sum} F\brackets{a, x} + F\brackets{x, x}}
        \end{array}
        \quad& \parens{a = b \ne 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            F\brackets{b, a}
        \end{array}
        \quad& \parens{a < b \ne 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            \displaystyle
            \sum_{x = 0}^{a - 1}{F\brackets{x, b}}
        \end{array}
        \quad& \parens{b < a \ne 0}
    \end{cases}
" />

I made a naive top-down Python implementation and ran it against the example and it passed! However, it was really, really, terribly slow. Implementation:

import SolCountingTowers02 from "./_solutions.dynamic-programming/counting-towers--02-fail-topdown-naive.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (Extremely Slow)">
    <Code code={SolCountingTowers02} lang="py" />
</SpoilerBlock>

In an attempt to optimize, I tried expanding some calculations to get a feel for what we might build accumulators for. However, I found nothing. Here's what I tried:

<SpoilerBlock buttonLabel="Full Working">
<AlignLatex code="
    F\brackets{1, 1}
    &= F\brackets{1, 0} + F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{2, 2}
    &= F\brackets{2, 1} + F\brackets{1, 1}
    \\
    &\qquad + F\brackets{2, 0} + F\brackets{0, 0}
    \\
    &= \parens{F\brackets{1, 1} + F\brackets{0, 1}} + F\brackets{1, 1}
    \\
    &\qquad + \parens{F\brackets{1, 0} + F\brackets{0, 0}} + F\brackets{0, 0}
    \\
    &= 2 F\brackets{1, 1} + 2 F\brackets{0, 0} + 2 F\brackets{1, 0}
" />
<AlignLatex code="
    F\brackets{3, 3}
    &= F\brackets{3, 2} + F\brackets{2, 2}
    \\
    &\qquad + F\brackets{3, 1} + F\brackets{1, 1}
    \\
    &\qquad + F\brackets{3, 0} + F\brackets{0, 0}
    \\
    &= \parens{F\brackets{2, 2} + F\brackets{1, 2} + F\brackets{0, 2}} + F\brackets{2, 2}
    \\
    &\qquad + \parens{F\brackets{2, 1} + F\brackets{1, 1} + F\brackets{0, 1}} + F\brackets{1, 1}
    \\
    &\qquad + \parens{F\brackets{2, 0} + F\brackets{1, 0} + F\brackets{0, 0}} + F\brackets{0, 0}
    \\
    &= 2 F\brackets{2, 1} + 2 F\brackets{2, 2} + 2 F\brackets{2, 0}
    \\
    &\qquad + 2 F\brackets{1, 1} + 2 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 \parens{F\brackets{1, 1} + F\brackets{0, 1}} + 2 F\brackets{2, 2} + 2 F\brackets{2, 0}
    \\
    &\qquad + 2 F\brackets{1, 1} + 2 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{2, 2} + 2 F\brackets{2, 0}
    \\
    &\qquad + 4 F\brackets{1, 1} + 4 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{4, 4}
    &= F\brackets{4, 3} + F\brackets{3, 3}
    \\
    &\qquad + F\brackets{4, 2} + F\brackets{2, 2}
    \\
    &\qquad + F\brackets{4, 1} + F\brackets{1, 1}
    \\
    &\qquad + F\brackets{4, 0} + F\brackets{0, 0}
    \\
    &= \parens{F\brackets{3, 3} + F\brackets{2, 3} + F\brackets{1, 3} + F\brackets{0, 3}}
    + F\brackets{3, 3}
    \\
    &\qquad + \parens{F\brackets{3, 2} + F\brackets{2, 2} + F\brackets{1, 2} + F\brackets{0, 2}}
    + F\brackets{2, 2}
    \\
    &\qquad + \parens{F\brackets{3, 1} + F\brackets{2, 1} + F\brackets{1, 1} + F\brackets{0, 1}}
    + F\brackets{1, 1}
    \\
    &\qquad + \parens{F\brackets{3, 0} + F\brackets{2, 0} + F\brackets{1, 0} + F\brackets{0, 0}}
    + F\brackets{0, 0}
    \\
    &= \parens{F\brackets{3, 2} + F\brackets{3, 1} + F\brackets{3, 0}}
    + 2 F\brackets{3, 3}
    \\
    &\qquad + \parens{F\brackets{3, 2} + F\brackets{2, 1} + F\brackets{2, 0}}
    + 2 F\brackets{2, 2}
    \\
    &\qquad + \parens{F\brackets{3, 1} + F\brackets{2, 1} + F\brackets{1, 0}}
    + 2 F\brackets{1, 1}
    \\
    &\qquad + \parens{F\brackets{3, 0} + F\brackets{2, 0} + F\brackets{1, 0}}
    + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3} + 2 F\brackets{3, 2} + 2 F\brackets{3, 1} + 2 F\brackets{3, 0}
    \\
    &\qquad + 2 F\brackets{2, 2} + 2 F\brackets{2, 1} + 2 F\brackets{2, 0}
    \\
    &\qquad + 2 F\brackets{1, 1} + 2 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3}
    + 2 \parens{F\brackets{2, 2} + F\brackets{2, 1} + F\brackets{2, 0}}
    + 2 \parens{F\brackets{2, 1} + F\brackets{1, 1} + F\brackets{1, 0}}
    + 2 F\brackets{3, 0}
    \\
    &\qquad + 2 F\brackets{2, 2}
    + 2 \parens{F\brackets{1, 1} + F\brackets{1, 0}}
    + 2 F\brackets{2, 0}
    \\
    &\qquad + 2 F\brackets{1, 1} + 2 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3}
    + 4 \parens{F\brackets{2, 1}}
    + 2 F\brackets{3, 0}
    \\
    &\qquad + 4 F\brackets{2, 2}
    + 4 F\brackets{2, 0}
    \\
    &\qquad + 6 F\brackets{1, 1} + 6 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3}
    + 4 \parens{F\brackets{1, 1} + F\brackets{1, 0}}
    + 2 F\brackets{3, 0}
    \\
    &\qquad + 4 F\brackets{2, 2}
    + 4 F\brackets{2, 0}
    \\
    &\qquad + 6 F\brackets{1, 1} + 6 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3} + 2 F\brackets{3, 0}
    \\
    &\qquad + 4 F\brackets{2, 2} + 4 F\brackets{2, 0}
    \\
    &\qquad + 10 F\brackets{1, 1} + 10 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
" />
</SpoilerBlock>

<AlignLatex code="
    F\brackets{1, 1}
    &= F\brackets{1, 0} + F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{2, 2}
    &= 2 F\brackets{1, 1} + 2 F\brackets{0, 0} + 2 F\brackets{1, 0}
" />
<AlignLatex code="
    F\brackets{3, 3}
    &= 2 F\brackets{2, 2} + 2 F\brackets{2, 0}
    \\
    &\qquad + 4 F\brackets{1, 1} + 4 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{4, 4}
    &= 2 F\brackets{3, 3} + 2 F\brackets{3, 0}
    \\
    &\qquad + 4 F\brackets{2, 2} + 4 F\brackets{2, 0}
    \\
    &\qquad + 10 F\brackets{1, 1} + 10 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
" />

I also tried expanding out the <Eq code="F\brackets{x, 0}" />'s:

<SpoilerBlock buttonLabel="Full Working">
<AlignLatex code="
    F\brackets{2, 2}
    &= 2 F\brackets{1, 1} + 2 F\brackets{0, 0} + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{1, 1} + 4 F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{3, 3}
    &= 2 F\brackets{2, 2} + 2 \parens{F\brackets{1, 0} + F\brackets{0, 0}}
    \\
    &\qquad + 4 F\brackets{1, 1} + 4 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{2, 2}
    \\
    &\qquad + 4 F\brackets{1, 1} + 6 F\brackets{1, 0}
    \\
    &\qquad + 4 F\brackets{0, 0}
    \\
    &= 2 F\brackets{2, 2} + 4 F\brackets{1, 1} + 10 F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{4, 4}
    &= 2 F\brackets{3, 3} + 2 \parens{F\brackets{2, 0} + F\brackets{1, 0} + F\brackets{0, 0}}
    \\
    &\qquad + 4 F\brackets{2, 2} + 4 F\brackets{2, 0}
    \\
    &\qquad + 10 F\brackets{1, 1} + 10 F\brackets{1, 0}
    \\
    &\qquad + 2 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3}
    \\
    &\qquad + 4 F\brackets{2, 2} + 6 F\brackets{2, 0}
    \\
    &\qquad + 10 F\brackets{1, 1} + 12 F\brackets{1, 0}
    \\
    &\qquad + 4 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3}
    \\
    &\qquad + 4 F\brackets{2, 2} + 6 \parens{F\brackets{0, 0} + F\brackets{0, 0}}
    \\
    &\qquad + 10 F\brackets{1, 1} + 12 F\brackets{0, 0}
    \\
    &\qquad + 4 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 3} + 4 F\brackets{2, 2} + 10 F\brackets{1, 1} + 28 F\brackets{0, 0}
" />
</SpoilerBlock>

<AlignLatex code="
    F\brackets{2, 2}
    &= 2 F\brackets{1, 1} + 4 F\brackets{0, 0}
    \\
    F\brackets{3, 3}
    &= 2 F\brackets{2, 2} + 4 F\brackets{1, 1} + 10 F\brackets{0, 0}
    \\
    F\brackets{4, 4}
    &= 2 F\brackets{3, 3} + 4 F\brackets{2, 2} + 10 F\brackets{1, 1} + 28 F\brackets{0, 0}
" />

I also tried expanding the <Eq code="F\brackets{x, x}" />'s:

<SpoilerBlock buttonLabel="Full Working">
<AlignLatex code="
    F\brackets{2, 2}
    &= 4 F\brackets{0, 0} + 4 F\brackets{1, 0}
" />
<AlignLatex code="
    F\brackets{3, 3}
    &= 2 \parens{4 F\brackets{0, 0} + 4 F\brackets{1, 0}} + 2 F\brackets{2, 0}
    \\
    &\qquad + 8 F\brackets{1, 0}
    \\
    &\qquad + 6 F\brackets{0, 0}
    \\
    &= 2 F\brackets{2, 0} + 16 F\brackets{1, 0} + 14 F\brackets{0, 0}
" />
<AlignLatex code="
    F\brackets{4, 4}
    &= 2 \parens{2 F\brackets{2, 0} + 16 F\brackets{1, 0} + 14 F\brackets{0, 0}} + 2 F\brackets{3, 0}
    \\
    &\qquad + 4 \parens{4 F\brackets{0, 0} + 4 F\brackets{1, 0}} + 4 F\brackets{2, 0}
    \\
    &\qquad + 20 F\brackets{1, 0}
    \\
    &\qquad + 12 F\brackets{0, 0}
    \\
    &= 2 F\brackets{3, 0} + 36 F\brackets{2, 0} + 68 F\brackets{1, 0} + 28 F\brackets{0, 0}
" />
</SpoilerBlock>

<AlignLatex code="
    F\brackets{2, 2}
    &= 4 F\brackets{0, 0} + 4 F\brackets{1, 0}
    \\
    F\brackets{3, 3}
    &= 2 F\brackets{2, 0} + 16 F\brackets{1, 0} + 14 F\brackets{0, 0}
    \\
    F\brackets{4, 4}
    &= 2 F\brackets{3, 0} + 36 F\brackets{2, 0} + 68 F\brackets{1, 0} + 28 F\brackets{0, 0}
" />

So let's try a different approach. I believe that the following sums should be easy to build accumulators for:

<DisplayLatex code="
    \sum_{x = 0}^n F\brackets{x, x}
    \qquad\qquad
    \sum_{x = 0}^n F\brackets{x, 0}
" />

But this sum is giving me headaches right now:

<DisplayLatex code="
    S\brackets{b} \coloneqq \sum_{x = 0}^{b - 1} F\brackets{x, b}
    \quad\text{for } b > 0
" />

That sum is an important part of the second line of the subproblem. So is it possible to build an accumulator for it?

<AlignLatex code="
    S\brackets{b}
    &= \sum_{x = 0}^{b - 1} F\brackets{b, x}
    = \sum_{x = 0}^{b - 1} \sum_{y = 0}^{b - 1} F\brackets{y, x}
" />

Now, let's visualize what's happening. For example, <Eq code="S\brackets{4}" /> is the sum of all of these:

<DisplayLatex code="
    \begin{array}{cccc}
        F\brackets{0, 3}
            & F\brackets{1, 3}
            & F\brackets{2, 3}
            & \xmemphR{F\brackets{3, 3}}
            \\
        F\brackets{0, 2}
            & F\brackets{1, 2}
            & \xmemphR{F\brackets{2, 2}}
            & F\brackets{3, 2}
            \\
        F\brackets{0, 1}
            & \xmemphR{F\brackets{1, 1}}
            & F\brackets{2, 1}
            & F\brackets{3, 1}
            \\
        \xmemphR{F\brackets{0, 0}}
            & F\brackets{1, 0}
            & F\brackets{2, 0}
            & F\brackets{3, 0}
    \end{array}
" />

Using the third case of the subproblem, we can reduce this to:

<DisplayLatex code="
    \begin{array}{cccc}
        {}
            & {}
            & {}
            & \xmemphR{F\brackets{3, 3}}
            \\
        {}
            & {}
            & \xmemphR{F\brackets{2, 2}}
            & 2 F\brackets{3, 2}
            \\
        {}
            & \xmemphR{F\brackets{1, 1}}
            & 2 F\brackets{2, 1}
            & 2 F\brackets{3, 1}
            \\
        \xmemphR{F\brackets{0, 0}}
            & 2 F\brackets{1, 0}
            & 2 F\brackets{2, 0}
            & 2 F\brackets{3, 0}
    \end{array}
" />

Based on this pattern, <Eq code="S\brackets{b}" /> is reducible to:

<DisplayLatex code="
    S\brackets{b}
    = \sum_{x = 0}^{b - 1} F\brackets{x, x}
    + 2 \sum_{x = 1}^{b - 1} S\brackets{x}
    \qquad\text{for } b > 0
" />

Therefore, we can calculate <Eq code="S\brackets{b}" /> using accumulators!

Let's now construct an alternative subproblem derived from this, where <Eq code="F'\brackets{n}" /> is the solution for the number of combinations to construct an <Eq code="n" />-sized tower:

<AlignLatex code="
    F'\brackets{n}
    &\coloneqq F\brackets{n, n}
    = \sum_{x=0}^{n - 1}\parens{F\brackets{n, x} + F\brackets{x, x}}
    \\
    &= \sum_{x=0}^{n - 1}F\brackets{n, x}
    + \sum_{x=0}^{n - 1}F\brackets{x, x}
    \\
    &= S\brackets{n}
    + \sum_{x=0}^{n - 1}F'\brackets{x}
    \qquad\text{for } n > 0
" />
<DisplayLatex code="
    F'\brackets{0} = 1
" />
<DisplayLatex code="
    S\brackets{n}
    = \sum_{x = 0}^{n - 1} F'\brackets{x}
    + 2 \sum_{x = 1}^{n - 1} S\brackets{x}
    \qquad\text{for } n > 0
" />

Attempting to simplify seems... too complicated for me to bother right now.

<SpoilerBlock buttonLabel="starting attempt at simplifying">
<AlignLatex code="
    F'\brackets{n}
    &= \sum_{x=0}^{n - 1}F'\brackets{x}
    + \sum_{x = 0}^{n - 1} F'\brackets{x}
    + 2 \sum_{x = 1}^{n - 1} S\brackets{x}
" />
</SpoilerBlock>

My Python top-down implementation passed the first two test cases containing queries for <Eq code="n \le 100" />, but we get `RUNTIME ERROR` for the other much bigger test cases, so my code probably goes over the memory usage limit of the auto-judge. Implementation:

import SolCountingTowers05 from "./_solutions.dynamic-programming/counting-towers--05-fail-topdown-runtime-error.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (RUNTIME ERROR)">
    <Code code={SolCountingTowers05} lang="py" />
</SpoilerBlock>

Reimplementing as bottom-up passed all tests:

import SolCountingTowers07 from "./_solutions.dynamic-programming/counting-towers--07-pass-bottomup.py?raw" //_

<Code code={SolCountingTowers07} lang="py" />


## Edit Distance <Spec href="https://cses.fi/problemset/task/1639" cdate="2024-04-08" />

Thinking through some edge cases, it was tempting to conclude that you'd never need to remove characters from the shorter word, but I believe this would break that assumption:

```
Test case:
   xxABCDEFGH
   ABCDEFGHxxx

The actual edit distance is 5:
   xxABCDEFGH   (0)
   xABCDEFGH    (1)
   ABCDEFGH     (2)
   ABCDEFGHx    (3)
   ABCDEFGHxx   (4)
   ABCDEFGHxxx  (5)

If we disallowed removing characters:
   xxABCDEFGH   (0)
   AxABCDEFGH   (1)
   ABABCDEFGH   (2)
   ...
   ABCDEFGHGH   (8)
   ABCDEFGHxH   (9)
   ABCDEFGHxx   (10)
   ABCDEFGHxxx  (11)
```

The first subproblem that comes to mind is two-dimensional, each dimension is an index into each string. Subproblem <Eq code="F\brackets{i, j}" /> is the edit distance of substrings `string1[0..i]` and `string2[0..j]` (`i` and `j` being inclusive).

I jumped straight into coding a solution first. Here's my Python top-down solution that passes many test cases but only fails due to `RUNTIME ERROR` (almost certainly due to memory usage):

import SolEditDistance02 from "./_solutions.dynamic-programming/edit-distance--02-fail-topdown-runtime-error.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (RUNTIME ERROR)">
    <Code code={SolEditDistance02} lang="py" />
</SpoilerBlock>

Writing out the subproblem:

<DisplayLatex code="
    s_1 = \text{string 1}
    \qquad\qquad
    s_2 = \text{string 2}
" />
<DisplayLatex code="
    F\brackets{i, j}
    = \begin{cases}
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            0
        \end{array}
        \quad& \parens{i < 0} \land \parens{j < 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            j + 1
        \end{array}
        \quad& \parens{i < 0} \land \parens{j \ge 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            i + 1
        \end{array}
        \quad& \parens{i \ge 0} \land \parens{j < 0}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            F\brackets{i - 1, j - 1}
        \end{array}
        \quad& \parens{i \ge 0}
            \land \parens{j \ge 0}
            \land \parens{s_1\brackets{i} = s_2\brackets{j}}
        \\
        \displaystyle
        \vphantom{\sum_{A}^A}
        \begin{array}{l}
            \displaystyle
            1 + \min(F\brackets{i - 1, j - 1},
            \\
            \qquad F\brackets{i - 1, j}, F\brackets{i, j - 1})
        \end{array}
        \quad& \text{otherwise}
    \end{cases}
" />

The first case is simply the case of two empty substrings. Naturally, empty substrings are already equivalent.

The second and third cases are the case where you compare an empty substring with a non-empty substring. Naturally, the solution is just the length of the non-empty substring.

My top-down Python solution simplifies these first three cases down with:

```py
if (i < 0) or (j < 0):
    return i + j + 2
```

The fourth case is the case where the two indices point to an equivalent character. This means no change needs to be made at that character.

The final case is where the two indices don't point to an equivalent character. There's a lot going on in that one line, so to see how this works, let's consider this example:

```
              v i=4
string 1: ...AB...
string 2: ..XY.....
             ^ j=3
```

The dots represent characters that we don't care about. Index `i` points to that `B` character in string 1, while index `j` points to that `Y` character in string 2.

To make it easier to understand, let's write this situation down in two different but conceptually identical ways:

<DisplayLatex code='
    \text{EditDistance}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
' />
<DisplayLatex code="
    F\brackets{4, 3}
" />

Recall that the problem specification allows these operations:

1. *Add one character to the string.*
2. *Remove one character from the string.*
3. *Replace one character in the string.*

Let's start with operation 3 because it's the simplest. Let's suppose we change the `B` in string 1 to `Y`:

<AlignLatex code='
    \text{EditDistance31}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    &= 1 + \text{EditDistance}\parens{\texttt{"...A\xmemphRC{Y}"}, \texttt{"..XY"}}
    \\
    &= 1 + \text{EditDistance}\parens{\texttt{"...A"}, \texttt{"..X"}}
' />
<DisplayLatex code="
    F_{31}\brackets{4, 3} = 1 + F\brackets{3, 2}
" />

The math works out identically even if we instead changed the `Y` in string 2 to `B`:

<AlignLatex code='
    \text{EditDistance32}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    &= 1 + \text{EditDistance}\parens{\texttt{"...AB"}, \texttt{"..X\xmemphRC{B}"}}
    \\
    &= 1 + \text{EditDistance}\parens{\texttt{"...A"}, \texttt{"..X"}}
' />
<DisplayLatex code="
    F_{32}\brackets{4, 3} = 1 + F\brackets{3, 2}
" />

Now, let's try operation 2. If we remove `B` from string 1:

<DisplayLatex code='
    \text{EditDistance21}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    = 1 + \text{EditDistance}\parens{\texttt{"...A"}, \texttt{"..XY"}}
' />
<DisplayLatex code="
    F_{21}\brackets{4, 3} = 1 + F\brackets{3, 3}
" />

Or if we remove `Y` from string 2 instead:

<DisplayLatex code='
    \text{EditDistance22}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    = 1 + \text{EditDistance}\parens{\texttt{"...AB"}, \texttt{"..X"}}
' />
<DisplayLatex code="
    F_{22}\brackets{4, 3} = 1 + F\brackets{4, 2}
" />

And finally, let's try operation 1. If we insert `Y` to string 1:

<AlignLatex code='
    \text{EditDistance11}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    &= 1 + \text{EditDistance}\parens{\texttt{"...AB\xmemphRC{Y}"}, \texttt{"..XY"}}
    \\
    &= 1 + \text{EditDistance}\parens{\texttt{"...AB"}, \texttt{"..X"}}
' />
<DisplayLatex code="
    F_{11}\brackets{4, 3} = 1 + F\brackets{4, 2}
" />

And if we instead insert `B` into string 2:

<AlignLatex code='
    \text{EditDistance12}\parens{\texttt{"...AB"}, \texttt{"..XY"}}
    &= 1 + \text{EditDistance}\parens{\texttt{"...AB"}, \texttt{"..XY\xmemphRC{B}"}}
    \\
    &= 1 + \text{EditDistance}\parens{\texttt{"...A"}, \texttt{"..XY"}}
' />
<DisplayLatex code="
    F_{12}\brackets{4, 3} = 1 + F\brackets{3, 3}
" />

Having gone through all six possible operations, it should be fairly straightforward to see how we get <Eq code="1 + \min\parens{F\brackets{i - 1, j - 1}, F\brackets{i - 1, j}, F\brackets{i, j - 1}}" /> as the final case of the subproblem.

I think it's also useful to point out that the equivalence of <Eq code="F_{21} = F_{12}" /> and <Eq code="F_{22} = F_{11}" /> can also be examined more intuitively.

Let's consider these two strings:

```
AXXX
XXX
```

To make the equivalent, you can either delete the `A` from string 1:

```
XXX
XXX
```

or, you can add an `A` to string 2:

```
AXXX
AXXX
```

Either way, we incurred a cost of <Eq code="1" /> operation.

My Python bottom-up implementation passes all tests:

import SolEditDistance03 from "./_solutions.dynamic-programming/edit-distance--03-pass-bottomup.py?raw" //_

<Code code={SolEditDistance03} lang="py" />

