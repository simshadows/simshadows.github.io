---
layout: ../../../../layouts/MDLayout.astro
title: Heaps
description: WIP
keywords: ["programming", "heaps", "binary heaps", "priority queue"]
---

import Latex from "@components/Latex";
import Todo from "@components/Todo";

# THIS PAGE IS A VERY EARLY WORK-IN-PROGRESS.

## Introduction

A *heap* is a tree data structure where a *heap property* is fulfilled:

- For a *max-heap*, every node's value is greater than or equal to each of their immediate children.
- For a *min-heap*, every node's value is lesser than or equal to their immediate children.

A *binary heap* is a heap with the form of a binary tree that also fulfills the *shape property*, requiring the tree to also form a *complete binary tree*, meaning:

1. all levels except the last are completely filled, and
2. the last level is filled from left to right.

Heaps are commonly used to implement the <u>*priority queue*</u> ADT.

Binary heaps are commonly efficiently implemented using an array. Notably, each row appears in the array in order from left to right. Since the binary heap is a complete binary tree, the array is a compact representation with no missing nodes before the last node.

Example of a *binary max-heap* data structure (colours are used only to help show structure):

![The conceptual tree structure of the heap.](./_heaps.images/generated-do-not-edit/intro-conceptual-tree.svg)

![Implementation using an array representation.](./_heaps.images/generated-do-not-edit/intro-array-rep.svg)

Some common operations:

<table class="general">
    <thead>
        <tr>
            <th>Operation</th>
            <th>Runtime</th>
            <th>Basic Summary</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><Latex code="\text{Push}(\textit{item})" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Add a single item.</td>
        </tr>
        <tr>
            <td><Latex code="\text{Pop}() \to \textit{item}" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Extract and remove the root of the heap (i.e. the <u>biggest item</u> of a max-heap, or the <u>smallest item</u> of a min-heap).</td>
        </tr>
        <tr>
            <td><Latex code="\text{Push-Pop}(\textit{item}) \to \textit{item}" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Equivalent to a push and then a pop, in that order. <em>Typically more efficient than using the individual operations.</em></td>
        </tr>
        <tr>
            <td><Latex code="\text{Pop-Push}(\textit{item}) \to \textit{item}" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Equivalent to a pop and then a push, in that order. <em>Typically more efficient than using the individual operations.</em></td>
        </tr>
        <tr>
            <td><Latex code="\text{Heapify}()" /></td>
            <td><Latex code="O(n)" /></td>
            <td>Convert an arbitrary <em>complete binary tree</em> into a valid heap.</td>
        </tr>
        <tr>
            <td><Latex code="\text{Get-Size}() \to \textit{size}" /></td>
            <td><Latex code="O(1)" /></td>
            <td>Get the number of items in the heap.</td>
        </tr>
        <tr>
            <td>(internal) <Latex code="\text{Sift-Up}(\textit{node})" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Moves a node up the tree until it is in a valid position.</td>
        </tr>
        <tr>
            <td>(internal) <Latex code="\text{Sift-Down}(\textit{node})" /></td>
            <td><Latex code="O(\log n)" /></td>
            <td>Moves a node down the tree until it is in a valid position.</td>
        </tr>
    </tbody>
</table>


## Array Indexing

<Todo>this</Todo>

