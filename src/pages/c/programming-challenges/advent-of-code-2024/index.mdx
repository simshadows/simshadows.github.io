---
layout: "@layouts/MDLayout.astro"
title: Advent of Code 2024 Solutions
description: My solutions and thoughts for Advent of Code 2024!
keywords: ["advent of code", "aoc", "2024", "day", "part", "solutions", "thoughts", "python", "c++", "cpp"]
---

import Divider from "@components/Divider";

import AlignLatex from "@components/latex/AlignLatex";
import DisplayLatex from "@components/latex/DisplayLatex";
import GatherLatex from "@components/latex/GatherLatex";
import Eq from "@components/latex/Eq";

import Code from "@components/Code.astro";
import Eqref from "@components/latex/Eqref";
import SpoilerBlock from "@components/SpoilerBlock.astro";
import Todo from "@components/Todo";

import Spec from "../_shared.Spec.astro"; //_

All solutions on this page were written by me without reading any hints or solutions.

My solutions aren't necessarily great, but they did the job and got me the answers.

My suggestion to run these solutions:
```
$ cat input.txt | ./solution.py
```

Links to the full challenge specifications are included throughout this document. The original specifications aren't allowed to be reproduced, so I can't repost them here.


<Divider />

## Day 1 <Spec href="https://adventofcode.com/2024/day/1" />

### Part 1 Solution

import Day01Part1 from "./_solutions/day01-part1.py?raw" //_

<Code code={Day01Part1} lang="py" />

### Part 2 Solution

import Day01Part2 from "./_solutions/day01-part2.py?raw" //_

<Code code={Day01Part2} lang="py" />


<Divider />

## Day 2 <Spec href="https://adventofcode.com/2024/day/2" />

### Part 1 Solution

import Day02Part1 from "./_solutions/day02-part1.py?raw" //_

<Code code={Day02Part1} lang="py" />

### Part 2 Solution

My first solution:

import Day02Part2v1 from "./_solutions/day02-part2-v1.py?raw" //_

<SpoilerBlock buttonLabel="Initial solution (Python)">
    <Code code={Day02Part2v1} lang="py" />
</SpoilerBlock>

In an attempt to make a more compact solution, I reimplemented with a lambda:

import Day02Part2v3 from "./_solutions/day02-part2-v3.py?raw" //_

<Code code={Day02Part2v3} lang="py" />


<Divider />

## Day 3 <Spec href="https://adventofcode.com/2024/day/3" />

### Part 1 Solution

I cheated by using `eval()` rather than parsing out the `mul()` myself:

import Day03Part1 from "./_solutions/day03-part1.py?raw" //_

<Code code={Day03Part1} lang="py" />

### Part 2 Solution

My first solution, retaining the use of `eval()`:

import Day03Part2v1 from "./_solutions/day03-part2-v1.py?raw" //_

<SpoilerBlock buttonLabel="Initial solution (Python)">
    <Code code={Day03Part2v1} lang="py" />
</SpoilerBlock>

My attempt at making a more compact solution:

import Day03Part2v2 from "./_solutions/day03-part2-v2.py?raw" //_

<Code code={Day03Part2v2} lang="py" />


<Divider />

## Day 4 <Spec href="https://adventofcode.com/2024/day/4" />

### Part 1 Solution

My first attempt gets the right solution, but the approach is quite ugly:

import Day04Part1v1 from "./_solutions/day04-part1-v1.py?raw" //_

<Code code={Day04Part1v1} lang="py" />

*(Yes, I'm just trying to make meme solutions. That's why it's so ugly lol.)*

Alternative, nicer solution that just indexes into the existing graph:

import Day04Part1v2c from "./_solutions/day04-part1-v2c.py?raw" //_

<Code code={Day04Part1v2c} lang="py" />

### Part 2 Solution

import Day04Part2v2 from "./_solutions/day04-part2-v2.py?raw" //_

<Code code={Day04Part2v2} lang="py" />


<Divider />

## Day 5 <Spec href="https://adventofcode.com/2024/day/5" />

### Part 1 Solution

Things are getting a bit tough to make meme solutions, so I went for whatever works this time around. This got me the right answer quickly:

import Day05Part1v1a from "./_solutions/day05-part1-v1a.py?raw" //_

<SpoilerBlock buttonLabel="Initial solution (Python)">
    <Code code={Day05Part1v1a} lang="py" />
</SpoilerBlock>

But its runtime was pretty terrible. Doesn't matter though since solutions aren't timed. It only took a couple seconds anyway.

In preparation for Part 2, I converted the rules to a dict:

import Day05Part1v1b from "./_solutions/day05-part1-v1b.py?raw" //_

<SpoilerBlock buttonLabel="Faster solution (Python)">
    <Code code={Day05Part1v1b} lang="py" />
</SpoilerBlock>

More-compact solution:

import Day05Part1v2c from "./_solutions/day05-part1-v2c.py?raw" //_

<Code code={Day05Part1v2c} lang="py" />

### Part 2 Solution

Naive topological sort since it's easier and it ran fast enough for this problem anyway:

import Day05Part2v1 from "./_solutions/day05-part2-v1.py?raw" //_

<SpoilerBlock buttonLabel="Initial solution (Python)">
    <Code code={Day05Part2v1} lang="py" />
</SpoilerBlock>

More-compact (and honestly more-readable) solution that takes advantage of built-in sort:

import Day05Part2v2c from "./_solutions/day05-part2-v2c-alternative.py?raw" //_

<Code code={Day05Part2v2c} lang="py" />


<Divider />

## Day 6 <Spec href="https://adventofcode.com/2024/day/6" />

### Part 1 Solution

import Day06Part1v1b from "./_solutions/day06-part1-v1b.py?raw" //_

<Code code={Day06Part1v1b} lang="py" />

A technically more compact solution, but I think it's too unnecessarily unreadable:

import Day06Part1v2 from "./_solutions/day06-part1-v2.py?raw" //_

<SpoilerBlock buttonLabel="More-compact solution (Python)">
    <Code code={Day06Part1v2} lang="py" />
</SpoilerBlock>

### Part 2 Solution

import Day06Part2v1b from "./_solutions/day06-part2-v1b.py?raw" //_

<Code code={Day06Part2v1b} lang="py" />

We could technically make the solution more compact by using the same thing we did for Part 1, but again, it makes it unnecessarily unreadable to me.


<Divider />

## Day 7 <Spec href="https://adventofcode.com/2024/day/7" />

### Part 1 Solution

import Day07Part1v1b from "./_solutions/day07-part1-v1b.py?raw" //_

<Code code={Day07Part1v1b} lang="py" />

### Part 2 Solution

import Day07Part2v1 from "./_solutions/day07-part2-v1.py?raw" //_

<Code code={Day07Part2v1} lang="py" />


<Divider />

## Day 8 <Spec href="https://adventofcode.com/2024/day/8" />

### Part 1 Solution

import Day08Part1v1 from "./_solutions/day08-part1-v1.py?raw" //_

<Code code={Day08Part1v1} lang="py" />

### Part 2 Solution

import Day08Part2v1 from "./_solutions/day08-part2-v1.py?raw" //_

<Code code={Day08Part2v1} lang="py" />


<Divider />

## Day 9 <Spec href="https://adventofcode.com/2024/day/9" />

### Part 1 Solution

import Day09Part1v1 from "./_solutions/day09-part1-v1.py?raw" //_

<Code code={Day09Part1v1} lang="py" />

### Part 2 Solution

I attempted a Heap-based solution initially, but kept running into issues. In the end, I realized that my heap-based idea always assumes that you will always take the left-most of the largest contiguous sequence. For example, suppose you need to reallocate ID=2 here:

```
00..111....22
```

The actual correct answer here is to move it between the 0 and 1:
```
0022111......
```

However, my heap-based solution will place it after the 1 because that's how the heap is sorted:

```
00..11122....
```

I reimplemented using a much more naive algorithm. It takes quite a fair while to run, but it got me my answer:

import Day09Part2v1h from "./_solutions/day09-part2-v1h.py?raw" //_

<Code code={Day09Part2v1h} lang="py" />


<Divider />

## Day 10 <Spec href="https://adventofcode.com/2024/day/10" />

### Part 1 Solution

I skimmed the problem specification and accidentally solved Part 2 first.

When I reread the problem, I realized what Part 1 was actually asking me for, which brings me to my first correct solution for Part 1:

import Day10Part1v1b from "./_solutions/day10-part1-v1b.py?raw" //_

<Code code={Day10Part1v1b} lang="py" />

I made an attempt at making a more-compact solution, but it ends up quite unnecessarily unreadable:

import Day10Part1v3a from "./_solutions/day10-part1-v3a.py?raw" //_

<SpoilerBlock buttonLabel="More-compact but unreadable solution (Python)">
    <Code code={Day10Part1v3a} lang="py" />
</SpoilerBlock>

### Part 2 Solution

By the time I got to Part 2, I didn't have to do anything because I already accidentally wrote it for Part 1!

import Day10Part2v1 from "./_solutions/day10-part2-v1.py?raw" //_

<Code code={Day10Part2v1} lang="py" />

I made some attempts at writing a more-compact solution, but it really sacrifices readability and actually bloats the logic a bit:

import Day10Part2v2c from "./_solutions/day10-part2-v2c.py?raw" //_

<SpoilerBlock buttonLabel="More-compact but unreadable solution (Python)">
    <Code code={Day10Part2v2c} lang="py" />
</SpoilerBlock>


<Divider />

## Day 11 <Spec href="https://adventofcode.com/2024/day/11" />

### Part 1 Solution

I went for a naive simulation solution:

import Day11Part1v1 from "./_solutions/day11-part1-v1.py?raw" //_

<Code code={Day11Part1v1} lang="py" />

### Part 2 Solution

Part 1 runs far too slow.

In hindsight, this is obviously solveable with dp:

import Day11Part2v1 from "./_solutions/day11-part2-v1.py?raw" //_

<Code code={Day11Part2v1} lang="py" />

