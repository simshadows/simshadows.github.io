---
layout: "@layouts/MDLayout.astro"
title: Sorting and Searching - CSES Problem Set Solutions
description: My solutions and thoughts for the CSES problem set!
keywords: ["cp", "competitive programming", "leetcode", "algorithms", "data structures"]
---

import AlignLatex from "@components/latex/AlignLatex";
import DisplayLatex from "@components/latex/DisplayLatex";
import Eqref from "@components/latex/Eqref";
import GatherLatex from "@components/latex/GatherLatex";
import Eq from "@components/latex/Eq";
import Trl from "@components/latex/TableRowLatex";
import Trhl from "@components/latex/TableRowHLatex";

import FiguresBlock from "@components/figures/FiguresBlock";
import Fig from "@components/figures/Fig";

import Code from "@components/Code.astro";
import SpoilerBlock from "@components/SpoilerBlock.astro";
import Todo from "@components/Todo";

import Spec from "./../_shared.Spec.astro"; //_
import Intro from "./_common.intro.astro"; //_

import DArr from "./_common.DArr.astro"; //_
import UArr from "./_common.UArr.astro"; //_
import LArr from "./_common.LArr.astro"; //_
import RArr from "./_common.RArr.astro"; //_
import DLArr from "./_common.DLArr.astro"; //_
import URArr from "./_common.URArr.astro"; //_

import "./_sorting-and-searching.css";

import MissingCoinSumNumline from "./_sorting-and-searching.MissingCoinSumNumline.astro"; //_


<Intro />


## Distinct Numbers <Spec href="https://cses.fi/problemset/task/1621" cdate="2024-01-15" />

import SolDistinctNumbers from "./_solutions.sorting-and-searching/distinct-numbers--easier-to-read.py?raw" //_

<Code code={SolDistinctNumbers} lang="py" />


## Apartments <Spec href="https://cses.fi/problemset/task/1084/" cdate="2024-01-15" />

import SolApartments from "./_solutions.sorting-and-searching/apartments.py?raw" //_

<Code code={SolApartments} lang="py" />


## Ferris Wheel <Spec href="https://cses.fi/problemset/task/1090/" cdate="2024-01-16" />

import SolFerrisWheel from "./_solutions.sorting-and-searching/ferris-wheel.py?raw" //_

<Code code={SolFerrisWheel} lang="py" />


## Concert Tickets <Spec href="https://cses.fi/problemset/task/1091/" cdate="2024-01-18" />

I initially misunderstood the problem spec and thought that there was no time dimension to the problem, leading to two totally incorrect solutions:

import SolConcertTicketsFail01 from "./_solutions.sorting-and-searching/concert-tickets--fail01.py?raw" //_
import SolConcertTicketsFail02 from "./_solutions.sorting-and-searching/concert-tickets--fail02.py?raw" //_

<SpoilerBlock buttonLabel="Wrong Solution 1">
    <Code code={SolConcertTicketsFail01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Wrong Solution 2">
    <Code code={SolConcertTicketsFail02} lang="py" />
</SpoilerBlock>

The first logically correct solution I made was too slow due to <Eq code="O(n)" /> element deletions (even when I submitted it for `PyPy3`), leading to an overall time complexity is <Eq code="O(nm)" />. I would've liked to use a BST data structure like C++'s `std::multiset`, but Python lacks a standard library implementation.

import SolConcertTicketsFail03 from "./_solutions.sorting-and-searching/concert-tickets--fail03-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution">
    <Code code={SolConcertTicketsFail03} lang="py" />
</SpoilerBlock>

But at least I know the idea works, leading me to my first successful solution that passed all tests. I decided to rewrite in C++ since I wasn't having any luck in Python. This solution has time complexity <Eq code="O(m \log n + n \log n)" /> due to <Eq code="O(\log n)" /> operations on `std::multiset`, <Eq code="O(n \log n)" /> sorting, and <Eq code="O(m \log n)" /> main loop:

import SolConcertTickets from "./_solutions.sorting-and-searching/concert-tickets.cpp?raw" //_

<Code code={SolConcertTickets} lang="cpp" />

I decided to see if I can still make Python work without too much effort. I could probably try to paste a BST implementation, but I'd rather not.

I used *union find* to let me skip over "deleted" tickets efficiently rather than carry out <Eq code="O(n)" /> deletions. My solution passes on both `CPython3` and `PyPy3`:

import SolConcertTicketsAlt02 from "./_solutions.sorting-and-searching/concert-tickets--alternative02.py?raw" //_

<Code code={SolConcertTicketsAlt02} lang="py" />


## Restaurant Customers <Spec href="https://cses.fi/problemset/task/1619/" cdate="2024-01-19" />

I initially attempted Python, but TLE'd with PyPy3:

import SolRestaurantCustomersFail01 from "./_solutions.sorting-and-searching/restaurant-customers--fail01-tle.py?raw" //_

import SolRestaurantCustomersFail02 from "./_solutions.sorting-and-searching/restaurant-customers--fail02-tle.py?raw" //_

import SolRestaurantCustomersFail03 from "./_solutions.sorting-and-searching/restaurant-customers--fail03-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution 1">
    <Code code={SolRestaurantCustomersFail01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="TLE'd Python Solution 2">
    <Code code={SolRestaurantCustomersFail02} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="TLE'd Python Solution 3">
    <Code code={SolRestaurantCustomersFail03} lang="py" />
</SpoilerBlock>

Switching over to C++ and reimplementing my first Python solution passed all tests:

import SolRestaurantCustomers from "./_solutions.sorting-and-searching/restaurant-customers.cpp?raw" //_

<Code code={SolRestaurantCustomers} lang="cpp" />

<p><Todo>Maybe try to get a Python solution to pass!</Todo></p>


## Movie Festival <Spec href="https://cses.fi/problemset/task/1629/" cdate="2024-01-19" />

I went straight to C++ due to my experience with Python TLE'ing *Restaurant Customers*:

import SolMovieFestival from "./_solutions.sorting-and-searching/movie-festival.cpp?raw" //_

<Code code={SolMovieFestival} lang="cpp" />

As it turns out, my C++ solution wouldn't have to take advantage of BSTs, so I did a quick Python rewrite. It passes CPython3, but somehow TLE's with PyPy3:

import SolMovieFestivalAlt01 from "./_solutions.sorting-and-searching/movie-festival--alternative01.py?raw" //_

<Code code={SolMovieFestivalAlt01} lang="py" />


## Sum of Two Values <Spec href="https://cses.fi/problemset/task/1640/" cdate="2024-01-20" />

Two different approaches came to mind immediately: two-pointer, or dictionary.

I went for the dictionary approach first, but it TLE'd on both CPython3 and PyPy3:

import SolSumOfTwoValuesFail01 from "./_solutions.sorting-and-searching/sum-of-two-values--fail01-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution">
    <Code code={SolSumOfTwoValuesFail01} lang="py" />
</SpoilerBlock>

Redoing it with a two-pointer approach passed all tests for CPython3:

import SolSumOfTwoValues from "./_solutions.sorting-and-searching/sum-of-two-values.py?raw" //_

<Code code={SolSumOfTwoValues} lang="py" />

In retrospect, I should've started with the two-pointer approach. It turned out much simpler to work through.


## Maximum Subarray Sum <Spec href="https://cses.fi/problemset/task/1643/" cdate="2024-01-22" />

import SolMaximumSubarraySum from "./_solutions.sorting-and-searching/maximum-subarray-sum.py?raw" //_

<Code code={SolMaximumSubarraySum} lang="py" />


## Stick Lengths <Spec href="https://cses.fi/problemset/task/1074" cdate="2024-01-23" />

This one took an embarrassing amount of time for me to figure out.

I started off with an incorrect solution of taking the average stick length and finding the cost of bringing all sticks to the average length:

import SolStickLengthsFail01 from "./_solutions.sorting-and-searching/stick-lengths--fail01-wrong-answers.py?raw" //_

<SpoilerBlock buttonLabel="Wrong Solution 1">
    <Code code={SolStickLengthsFail01} lang="py" />
</SpoilerBlock>

I mistakenly thought maybe it was a rounding error with finding the average since I used floor/integer division. In an attempt to solve this, I took the best solution of the floored average and floored average plus 1. This also produced incorrect answers:

import SolStickLengthsFail02 from "./_solutions.sorting-and-searching/stick-lengths--fail02-wrong-but-a-bit-better.py?raw" //_

<SpoilerBlock buttonLabel="Wrong Solution 2">
    <Code code={SolStickLengthsFail02} lang="py" />
</SpoilerBlock>

The next idea I tried was to sort the sticks and use a two-pointer approach.

The first key insight in working through a two-pointer solution was that I didn't need to worry about the order of the sticks, so I could sort the sticks. With a sorted array, I found that you can incrementally calculate costs. For example, consider a sorted sticks array <Eq code="\brackets{1, 2, 4, 6, 6, 7, 8, 8}" />. We can draw this with ASCII art:

```
                        H   H
                    H   H   H
            H   H   H   H   H
            H   H   H   H   H
        H   H   H   H   H   H
        H   H   H   H   H   H
    H   H   H   H   H   H   H
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7    <-- indices
```

Suppose we want all the sticks to all be 6 units long. Sticks at indices 3 and 4 are already 6 units long, but the sticks to the left (indices 0-2) must be increased in length while the sticks to the right (indices 5-7) must have their lengths reduced:

```
                        .   .
                    .   .   .
.   .   .   H   H   H   H   H
.   .   .   H   H   H   H   H
.   .   H   H   H   H   H   H
.   .   H   H   H   H   H   H
.   H   H   H   H   H   H   H
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7
```

We see that the cost to make all sticks 6 units long is <Eq code="5 + 4 + 2 + 0 + 0 + 1 + 2 + 2 = 16" />.

To calculate these costs incrementally, we might start by making all sticks the same length as stick 0. **For purposes of this discussion, we say that we are "visiting stick 0".** The diagram for visiting stick 0:

```
                        .   .
                    .   .   .
            .   .   .   .   .
            .   .   .   .   .
        .   .   .   .   .   .
        .   .   .   .   .   .
    .   .   .   .   .   .   .
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7
```

We also precalculate the cost of this configuration. Here, we see that the cost when visiting stick 0 is <Eq code="1 + 3 + 5 + 5 + 6 + 7 + 7 = 34" />.

Now let's visit the next stick up (stick 1). Since it's hard to see what's going on in the example, I will skip over explaining it. Drawing it out:

```
                        .   .
                    .   .   .
            .   .   .   .   .
            .   .   .   .   .
        .   .   .   .   .   .
        .   .   .   .   .   .
.   H   H   H   H   H   H   H
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7
```

The cost when visiting stick 1 is <Eq code="28" />.

Now, this is where things get more interesting. Let's visit the next stick up (stick 2). The diagram should now look like this:

```
                        .   .
                    .   .   .
            .   .   .   .   .
            .   .   .   .   .
.   .   H   H   H   H   H   H
.   .   H   H   H   H   H   H
.   H   H   H   H   H   H   H
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7
```

The cost when visiting stick 2 is <Eq code="3 + 2 + 0 + 2 + 2 + 3 + 4 + 4 = 20" />.

Notice that the difference between visiting stick 1 and visiting stick 2 is "two rectangles".

"Rectangle 1" spans sticks 0-1:

```
                          .   .
                      .   .   .
              .   .   .   .   .
              .   .   .   .   .
 [X   X]  H   H   H   H   H   H
 [X   X]  H   H   H   H   H   H
  .   H   H   H   H   H   H   H
  H   H   H   H   H   H   H   H

  0   1   2   3   4   5   6   7
```

"Rectangle 2" spans sticks 2-7:

```
                        .   .
                    .   .   .
            .   .   .   .   .
            .   .   .   .   .
.   .  [X   X   X   X   X   X]
.   .  [X   X   X   X   X   X]
.   H   H   H   H   H   H   H
H   H   H   H   H   H   H   H

0   1   2   3   4   5   6   7
```

The widths and heights of these rectangles simply depend on:

1. the current visited stick, and
2. the difference in length between the currently-visited stick and the previously-visited stick.

To calculate the cost of visiting the current stick, we can simply add the size of "rectangle 1" to the cost, and then subtract the size of "rectangle 2" from the cost:

<AlignLatex code="
    \text{cost of visiting stick $2$}
    &= \text{cost of visiting stick $1$}
    + \text{rectangle 1}
    - \text{rectangle 2}
    \\
    &= 28 + \parens{2 \times 2} - \parens{6 \times 2}
    \\
    &= 28 + 4 - 12
    \\
    &= 20
" />

This cost matches the cost we calculated for visiting stick 2.

This method of course generalizes across the entire sorted array of sticks.

The second key insight I made while working out how a two-pointer solution might work was that the optimal stick size will always be one of the stick sizes that already exist in the array.

To get at why this is the case, let's consider a very simple sorted array of sticks <Eq code="\brackets{3, 3, 5, 5, 5, 5}" />:

```
        H   H   H   H
        H   H   H   H
H   H   H   H   H   H
H   H   H   H   H   H
H   H   H   H   H   H

0   1   2   3   4   5
```

We can roughly do two things:

1. we can add length to sticks 0-1, or
2. we can remove length from sticks 2-5.

Doing the first option will add 2 to the cost for every unit of length added, while doing the second option will add 4 to the cost for every unit of length removed. Clearly, the best option is to simply bring sticks 0-1 up to height 5, which incurs a total cost of 4. Note that if you "meet halfway" by bringing all sticks to length 4, you still find that cutting the length of sticks 2-5 is less-efficient than adding length to sticks 0-1.

This should be sufficient background for understanding my remaining solutions.

Unfortunately, my two-pointer idea didn't work and gave wrong answers. The idea of the algorithm was that I would start with a sort of "visit the left pointer" and "visit the right pointer", then I check which pointer is cheaper to move. I keep moving the pointers until they meet, and the meeting point is my solution. The issue is evidently locally suboptimal solutions which I won't expand further on. In retrospect, I should've checked the edge cases better. The failed two-pointer solution:

import SolStickLengthsFail03 from "./_solutions.sorting-and-searching/stick-lengths--fail03-wrong-answer.py?raw" //_

<SpoilerBlock buttonLabel="Wrong Solution 3">
    <Code code={SolStickLengthsFail03} lang="py" />
</SpoilerBlock>

I quickly come up with the idea to just try visiting every stick in the sorted list and getting the lowest-cost. My very first solution that passed all tests:

import SolStickLengths from "./_solutions.sorting-and-searching/stick-lengths.py?raw" //_

<SpoilerBlock buttonLabel="Original Successful Solution">
    <Code code={SolStickLengths} lang="py" />
</SpoilerBlock>

I also did another solution that is based around a cumulative sum array:

import SolStickLengthsAlt03 from "./_solutions.sorting-and-searching/stick-lengths--alternative03.py?raw" //_

<SpoilerBlock buttonLabel="Alternative Solution">
    <Code code={SolStickLengthsAlt03} lang="py" />
</SpoilerBlock>

My favourite variant I made that uses this incremental solutions idea:

import SolStickLengthsAlt05 from "./_solutions.sorting-and-searching/stick-lengths--alternative05.py?raw" //_

<Code code={SolStickLengthsAlt05} lang="py" />

That solution notably uses a conditional break ("short circuit"). This works since cost behaves like a parabola when visiting each stick in a sorted stick array.

**This is the point where I spoiled the answers for myself and looked at other peoples' solutions.**

After spoiling solutions, a common one I found was to simply visit the median/middle stick:

import SolStickLengthsAlt06 from "./_solutions.sorting-and-searching/stick-lengths--alternative06.py?raw" //_

<Code code={SolStickLengthsAlt06} lang="py" />

To gain an intuition for going on here, let's try a skewed distribution <Eq code="\brackets{1, 2, 2, 4, 8, 9, 10}" />. The median is calculated as <Eq code="\texttt{(len(sticks) // 2)} = \floor{7 / 2} = \floor{3.5} = 3" />. Sketching out the diagram:

```
                        H
                    H   H
                H   H   H
                H   H   H
                H   H   H
                H   H   H
            H   H   H   H
            H   H   H   H
    H   H   H   H   H   H
H   H   H   H   H   H   H

0   1   2   3   4   5   6
            ^
          median
```

All sticks need to be brought to the same length, so the outliers necessarily have to be dealt with anyway. The following diagram incurs a cost of <Eq code="4" />:

```
                            .
                        .   .
                   [H   H   H]
                   [H   H   H]
                   [H   H   H]
                   [H   H   H]
               H   [H   H   H]
               H   [H   H   H]
 [.   H   H]   H   [H   H   H]
 [H   H   H]   H   [H   H   H]
  
  0   1   2    3    4   5   6
               ^
```

I also highlighted two rectangles in the diagram above. Notice that both rectangles are the same width, therefore they will incur the same cost to modify.

The one stick that we shouldn't touch is the median stick (stick 3) since modifying it at all will incur unnecessary cost. Therefore, stick 3's length will be the target length for all the sticks. The cheapest cost for this distribution is to then lengthen the left rectangle by 2, and shorten the right rectangle by <Eq code="4" />:


```
                            .
                        .   .
                    .   .   .
                    .   .   .
                    .   .   .
                    .   .   .
 [.   .   .]   H   [H   H   H]
 [.   .   .]   H   [H   H   H]
 [.   H   H]   H   [H   H   H]
 [H   H   H]   H   [H   H   H]
  
  0   1   2    3    4   5   6
               ^
```

These rectangle-lengthenings and shortenings adds <Eq code="(2 \times 3) + (4 \times 3) = 6 + 12 = 18" />, so the total cost is <Eq code="4 + 18 = 22" />, and this is the cheapest cost for this distribution.

But what about an even-numbered distribution? Let's try <Eq code="\brackets{1, 2, 2, 4, 9, 10}" />. The ~~median~~ middle is calculated as <Eq code="\floor{6 / 2} = 3" />. Sketching out the diagram:

```
                    H
                H   H
                H   H
                H   H
                H   H
                H   H
            H   H   H
            H   H   H
    H   H   H   H   H
H   H   H   H   H   H

0   1   2   3   4   5
            ^
          middle
```

Once again, we deal with the outliers, this time incurring a cost of <Eq code="2" />:

```
                        .
                   [H   H]
                   [H   H]
                   [H   H]
                   [H   H]
                   [H   H]
               H   [H   H]
               H   [H   H]
 [.   H   H]   H   [H   H]
 [H   H   H]   H   [H   H]
  
  0   1   2    3    4   5
               ^
```

This time, the two rectangles are mismatched in width!

However, we can conceptually combine the middle stick with the rectangle with the smallest width. This is efficient because the smaller width is cheaper to modify than the wider width. This will always be the rectangle to the right. Modifying this right rectangle and thereby adding to the cost by <Eq code="2 \times 5 = 10" />:

```
                        .
                    .   .
                    .   .
                    .   .
                    .   .
                    .   .
               [H   H   H]
               [H   H   H]
 [.   H   H]   [H   H   H]
 [H   H   H]   [H   H   H]
  
  0   1   2     3   4   5
                ^
              middle
```

Now, there's just two rectangles. Trivially, you can modify either of them and it will incur the same cost. For fun, let's modify both of them, thereby adding to the cost by <Eq code="(3 \times 1) + (3 \times 1) = 6" />:

```
                        .
                    .   .
                    .   .
                    .   .
                    .   .
                    .   .
                .   .   .
 [.   .   .]   [H   H   H]
 [.   H   H]   [H   H   H]
 [H   H   H]   [H   H   H]
  
  0   1   2     3   4   5
                ^
```

The total cost of these operations is <Eq code="2 + 10 + 6 = 18" />, and this is the cheapest cost.

Though, in practice, we'll just keep things simple and bring everything to the same level as the middle stick, which is what that Python implementation does.


## Missing Coin Sum <Spec href="https://cses.fi/problemset/task/2183/" cdate="2024-01-24" />

This was a fun one to figure out!

I started by sorting the input array and thinking about how smaller coins have a different effect to larger coins in that they allow for "finer-grained sums". Therefore, dealing with the smaller coins first may be a useful strategy for this problem.

My next idea was to think of intervals of consecutive integers (i.e. sequences where each element is one greater than the previous). I thought about different ideas like needing to track intervals using tuples and whether or not to start the intervals from <Eq code="1" />, but here's what I found worked.

We track a single unbroken interval of possible coin sums that starts with <Eq code="0" />. The basic idea is that we incrementally grow this interval until we find a gap where a sum isn't possible. To understand what this means, let's look at an example.

Let's consider a simple sorted list of four coins <Eq code="\brackets{1, 2, 6, 7}" />. Let's *conceptually* initialize a set of "seen coins" called <Eq code="\text{seen}" />. I say *conceptually* because the set isn't explicitly initialized in my Python implementation, but it will be useful for understanding it.

Before starting the loop, the set is empty:

<DisplayLatex code="
    \text{seen} = \braces{}
" />

We find that the only possible coin sum for <Eq code="\text{seen} = \braces{}" /> is <Eq code="0" /> because <Eq code="\text{seen}" /> is an empty set. Let's track this with an interval we'll call <Eq code="\text{sums}" />, and also sketch it out using an integer number line (with bold **X** representing set membership):

<DisplayLatex code="
    \text{sums} = [0, 1)
" />

<MissingCoinSumNumline>
    <td class="mcsi-marked">X</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
</MissingCoinSumNumline>

*(This interval notation <Eq code="[0, 1)" /> means an interval starting at <Eq code="0" /> (inclusive) and ending at <Eq code="1" /> (exclusive). This notation is typically used for real number intervals rather than integers, but I like borrowing the notation for integer intervals as well.)*

Now, let's start the loop.

Let's visit the first element of the sorted coins list:

```
[ 1, 2, 6, 7 ]
  ^
```

Therefore we add the element to the `seen` set:

<DisplayLatex code="
    \text{seen} = \braces{1}
" />

And therefore, the set of possible coin sums is:

<DisplayLatex code="
    \text{sums} = [0, 2)
" />

<MissingCoinSumNumline>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
</MissingCoinSumNumline>

This new interval <Eq code="\text{sums} = [0, 2)" /> makes sense since there are now two possible subsets of <Eq code="\text{seen} = \braces{1}" />:

<AlignLatex code="
    \sum \braces{}  &= 0 \\
    \sum \braces{1} &= 1
" />

Let's visit the next element:

```
[ 1, 2, 6, 7 ]
     ^
```

Therefore we add the element to the `seen` set:

<DisplayLatex code="
    \text{seen} = \braces{1, 2}
" />

And therefore, the set of possible coin sums is:

<DisplayLatex code="
    \text{sums} = [0, 4)
" />

<MissingCoinSumNumline>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
</MissingCoinSumNumline>

This new interval <Eq code="\text{sums} = [0, 4)" /> makes sense since there are four possible subsets of <Eq code="\text{seen} = \braces{1, 2}" />, each with unique sum values:

<GatherLatex code="
    \begin{aligned}
        \sum \braces{}  &= 0 \\
        \sum \braces{1} &= 1
    \end{aligned}
    \quad\qquad
    \begin{aligned}
        \sum \braces{2} &= 2 \\
        \sum \braces{1, 2} &= 3
    \end{aligned}
" />

Let's visit the next element:

```
[ 1, 2, 6, 7 ]
        ^
```

And now, we notice something interesting happens:

<GatherLatex code="
    \text{seen} = \braces{1, 2, 6} \\
    \text{sums} = \text{???}
" />

<MissingCoinSumNumline>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td></td>
    <td></td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td class="mcsi-marked">X</td>
    <td></td>
</MissingCoinSumNumline>

<GatherLatex code="
    \begin{aligned}
        \sum \braces{}  &= 0 \\
        \sum \braces{1} &= 1
    \end{aligned}
    \quad\qquad
    \begin{aligned}
        \sum \braces{2} &= 2 \\
        \sum \braces{1, 2} &= 3
    \end{aligned}
    \quad\qquad
    \begin{aligned}
        \sum \braces{6} &= 6 \\
        \sum \braces{1, 6} &= 7 \\
        \sum \braces{2, 6} &= 8 \\
        \sum \braces{1, 2, 6} &= 9
    \end{aligned}
" />

We now have a gap in what should've been a single unbroken interval! The algorithm terminates here, and the answer is <Eq code="4" />.

My solution uses these ideas, but with many shortcuts applied:

import SolMissingCoinSum from "./_solutions.sorting-and-searching/missing-coin-sum.py?raw" //_

<Code code={SolMissingCoinSum} lang="py" />


## Collecting Numbers <Spec href="https://cses.fi/problemset/task/2216/" cdate="2024-01-26" />

import SolCollectingNumbers from "./_solutions.sorting-and-searching/collecting-numbers.py?raw" //_

<Code code={SolCollectingNumbers} lang="py" />


## Collecting Numbers II <Spec href="https://cses.fi/problemset/task/2217/" cdate="2024-01-27" />

I took ages to get my first successful solution, and I feel like there should be a much simpler solution here. I originally went for C++ for the BST data structures, but my attempts to use BSTs didn't work out due to the complexity of my idea of using tuple representations of range intervals (tracking the start and end of each interval). I eventually settled on just tracking the base of these range intervals.

This solution comes awfully close to TLE'ing (it took 0.88s for test 2).

<p><Todo>There is almost certainly a better solution. I should meditate on this some more.</Todo></p>

import SolCollectingNumbers2 from "./_solutions.sorting-and-searching/collecting-numbers2.cpp?raw" //_

<Code code={SolCollectingNumbers2} lang="cpp" />


## Playlist <Spec href="https://cses.fi/problemset/task/1141/" cdate="2024-01-27" />

I went for a sliding window solution:

import SolPlaylist from "./_solutions.sorting-and-searching/playlist.py?raw" //_

<Code code={SolPlaylist} lang="py" />


## Towers <Spec href="https://cses.fi/problemset/task/1073" cdate="2024-01-27" />

I went for C++ for the BST implementations:

import SolTowers from "./_solutions.sorting-and-searching/towers.cpp?raw" //_

<Code code={SolTowers} lang="cpp" />


## Traffic Lights <Spec href="https://cses.fi/problemset/task/1163/" cdate="2024-01-28" />

I don't like this problem description. It's not very clear how it's meant to work, so I spent a long time trying ideas on the example until something worked.

I initially thought there were <Eq code="x + 1" /> "units", and a traffic light would take up one whole unit. Therefore, for the example input of <Eq code="x = 8" /> and <Eq code="p = \brackets{3, 6, 2}" />, I sketched out the example and found my interpretation to be wrong:

```
012345678    passage lengths: [9]
012 45678    passage lengths: [3, 5]       longest passage: 5
012 45 78    passage lengths: [3, 2, 2]    longest passage: 3
01  45 78    passage lengths: [2, 2, 2]    longest passage: 2
```

I then tried interpreting the <Eq code="p" /> positions as zero-length boundaries, which was also wrong:

```
012345678       passage lengths: [9]
012 345678      passage lengths: [3, 6]          longest passage: 6
012 345 678     passage lengths: [3, 3, 3]       longest passage: 3
01 2 345 678    passage lengths: [2, 1, 3, 3]    longest passage: 3
```

```
012345678       passage lengths: [9]
0123 45678      passage lengths: [4, 5]          longest passage: 5
0123 456 78     passage lengths: [4, 3, 2]       longest passage: 4
012 3 456 78    passage lengths: [3, 1, 3, 2]    longest passage: 3
```

Only when I considered position <Eq code="x" /> to implicitly come with a traffic light did the example make sense:

```
01234567       passage lengths: [8]
012 34567      passage lengths: [3, 5]          longest passage: 5
012 345 67     passage lengths: [3, 3, 2]       longest passage: 3
01 2 345 67    passage lengths: [2, 1, 3, 2]    longest passage: 3
```

I went for C++ for the BST implementations. It went awfully close to TLE'ing (it took 0.98-0.99s for many tests).

import SolTrafficLights from "./_solutions.sorting-and-searching/traffic-lights.cpp?raw" //_

<Code code={SolTrafficLights} lang="cpp" />

I also had the idea to iterate in reverse and use union find to merge together intervals. It turned out very cursed, but somehow runs faster than my initial C++ implementation, even in CPython3:

<p><Todo>There should be a better solution. I should meditate on this some more.</Todo></p>

import SolTrafficLightsAlt01 from "./_solutions.sorting-and-searching/traffic-lights--alternative01-reversed-dsu-based.py?raw" //_

<Code code={SolTrafficLightsAlt01} lang="py" />


## Josephus Problem I <Spec href="https://cses.fi/problemset/task/2162/" cdate="2024-01-29" />

I used union find to calculate skips:

import SolJosephusProblemI from "./_solutions.sorting-and-searching/josephus-problem-i.py?raw" //_

<Code code={SolJosephusProblemI} lang="py" />

Rewritten in C++:

import SolJosephusProblemIAlt04 from "./_solutions.sorting-and-searching/josephus-problem-i--alternative04.cpp?raw" //_

<SpoilerBlock buttonLabel="C++ Rewrite">
    <Code code={SolJosephusProblemIAlt04} lang="py" />
</SpoilerBlock>

Along the way, I learnt something interesting about chain assignments in Python:

import SolJosephusProblemIFail01 from "./_solutions.sorting-and-searching/josephus-problem-i--fail01.py?raw" //_
import SolJosephusProblemIAlt01 from "./_solutions.sorting-and-searching/josephus-problem-i--alternative01.py?raw" //_

<SpoilerBlock buttonLabel="Python Chain Assignment Experimentation">
    In trying to refactor my solution to something nicer, I found this version to fail:

    <Code code={SolJosephusProblemIFail01} lang="py" />

    As it turns out, Python chained assignments work by evaluating the right-most expression, then assigning to the remaining targets from left to right ([source](https://stackoverflow.com/questions/48633951/why-does-chained-assignment-work-this-way)):

    ```
    Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> m = {1: 2}
    >>> i = 1
    >>> i = m[i] = "x"
    >>> i
    'x'
    >>> m
    {1: 2, 'x': 'x'}
    ```

    In the example above, if `"x"` assigns to `m[i]` first before assigning `m[i]` to `i`, you'd expect it to behave like:

    ```
    Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> m = {1: 2}
    >>> i = 1
    >>> m[i] = "x"
    >>> i = m[i]
    >>> i
    'x'
    >>> m
    {1: 'x'}
    ```

    But instead, it behaves like:

    ```
    Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> m = {1: 2}
    >>> i = 1
    >>> i = "x"
    >>> m[i] = "x"
    >>> i
    'x'
    >>> m
    {1: 2, 'x': 'x'}
    ```

    So if I wanted to refactor away the explicit new variable `nxt`, it would have to be rewritten as:

    <Code code={SolJosephusProblemIAlt01} lang="py" />

    This version passes all tests.
</SpoilerBlock>

I also wrote a much simpler solution that passes according to my understanding of the problem, but it doesn't pass the tests:

import SolJosephusProblemIFail02 from "./_solutions.sorting-and-searching/josephus-problem-i--fail02.py?raw" //_

<SpoilerBlock buttonLabel="Failed Solution">
    This solution assumes that the current child will remove the child before them. For example, suppose we have four children:

    ```
    1 2 3 4
    ```

    Child 1 will remove child 4:

    ```
    1 2 3
    ^
    ```

    Child 2 will remove child 1:
    ```
      2 3
      ^
    ```

    Child 3 will remove child 2:

    ```
        3
        ^
    ```

    And child 3 will also remove itself. Therefore the solution for four children would be `4 1 2 3`.

    Python implementation:

    <Code code={SolJosephusProblemIFail02} lang="py" />
</SpoilerBlock>

<p><Todo>I'm actually not yet sure why that solution isn't considered valid. Nothing in the problem specification seems to disallow it.</Todo></p>

Alternative C++ solution using BST/`std::set`, though it somehow runs slower than the Python solution even with IO desync:

import SolJosephusProblemIAlt02 from "./_solutions.sorting-and-searching/josephus-problem-i--alternative02.cpp?raw" //_

<Code code={SolJosephusProblemIAlt02} lang="cpp" />

Another solution, this time using list shifting for fast deletions. Actually runs faster than my previous solutions (including C++). The item deletion overhead is fast since we're deleting half of the set at any given time. Implementation:

import SolJosephusProblemIAlt06 from "./_solutions.sorting-and-searching/josephus-problem-i--alternative06.py?raw" //_

<Code code={SolJosephusProblemIAlt06} lang="py" />

I rewrote it in C++, but it's somehow slower than the Python version:

import SolJosephusProblemIAlt07 from "./_solutions.sorting-and-searching/josephus-problem-i--alternative07.cpp?raw" //_

<SpoilerBlock buttonLabel="C++ Rewrite">
    <Code code={SolJosephusProblemIAlt07} lang="cpp" />
</SpoilerBlock>


## Josephus Problem II [UNFINISHED] <Spec href="https://cses.fi/problemset/task/2163/" cdate="2024-01-29" />

I used my Josephus Problem I union find solution as a starting point. After a cold start of misunderstanding the problem specification, my first logically correct solution ran out of time and caused a stack overflow with the default recursion limit). Not unexpected since it's <Eq code="O(n k)" /> for quite large <Eq code="n" /> and <Eq code="k" />:

import SolJosephusProblemIIFail02 from "./_solutions.sorting-and-searching/josephus-problem-ii--fail02-tle-and-stack-overflow.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution 1">
    <Code code={SolJosephusProblemIIFail02} lang="py" />
</SpoilerBlock>

I tried adding a modulo to cut down on the <Eq code="k" />-iterations. It passes some more tests, but as expected, it still TLE's and causes a stack overflow:

import SolJosephusProblemIIFail03 from "./_solutions.sorting-and-searching/josephus-problem-ii--fail03-tle-and-stack-overflow.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution 2">
    <Code code={SolJosephusProblemIIFail03} lang="py" />

    The only difference from the first TLE'd solution is these lines:

    ```py
    for i in range(n):
        for _ in range(k % (n - i)):
    ```
</SpoilerBlock>

<p><Todo>Finish this</Todo></p>


## Nested Ranges Check <Spec href="https://cses.fi/problemset/task/2168" cdate="2024-01-31" />

My first attempt TLE'd, but otherwise seems promising in terms of correctness:

import SolNestedRangesCheckFail01 from "./_solutions.sorting-and-searching/nested-ranges-check--fail01-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution">
    <Code code={SolNestedRangesCheckFail01} lang="py" />
</SpoilerBlock>

Rewriting it for C++ passed all tests! Full solution:

import SolNestedRangesCheck from "./_solutions.sorting-and-searching/nested-ranges-check.cpp?raw" //_

<Code code={SolNestedRangesCheck} lang="cpp" />

I also made some further modifications to add I/O desync and switch `solution` to `std::vector<bool>`. Both very slightly improved performance.

<p><Todo>Maybe we can still get more significant performance wins?</Todo></p>


## Nested Ranges Count [UNFINISHED] <Spec href="https://cses.fi/problemset/task/2169" cdate="2024-02-01" />

I started by looking into how to count intervals contained within another interval.

My first idea was to sort the ranges twice (once sorted by start point and once sorted by endpoint), and calculate cumulative counts, to be stored in BSTs/`std::map`. In an attempt to make this idea work, I looked into possible ways to write out the set arithmetic, but I conclude that it's unlikely to be a useful approach on its own.


<SpoilerBlock buttonLabel={"explanation of my attempt at a \"cumulative counts\" approach"}>
Let's have a look at a concrete example:

```
     t====
       a-
      b--
   c--- d---
e---       f---
 g------------
```

Above, we have one target interval labelled `t`, and seven other intervals that are also part of the set.

I see a few different operations to quickly count/enumerate relevant subsets just by a simple inequality. Here's a minimal subset of operations:

1. Total *other* intervals: <Eq code="\braces{a, b, c, d, e, f, g} \quad\longrightarrow\quad \text{count} = 7" />
2. Intervals with starting points after the start of `t`: <Eq code="\braces{a, b, d, f} \quad\longrightarrow\quad \text{count} = 4" />
3. Intervals with starting points after the end of `t`: <Eq code="\braces{f} \quad\longrightarrow\quad \text{count} = 1" />
4. Intervals with ending points after the start of `t`: <Eq code="\braces{a, b, c, d, f, g} \quad\longrightarrow\quad \text{count} = 6" />
5. Intervals with ending points after the end of `t`: <Eq code="\braces{d, f, g} \quad\longrightarrow\quad \text{count} = 3" />

For completeness, let's derive the opposites:

6. Intervals with starting points before the start of `t`: <Eq code="\text{count} = 7 - 4 = 3" />
7. Intervals with starting points before the end of `t`: <Eq code="\text{count} = 7 - 1 = 6" />
8. Intervals with ending points before the start of `t`: <Eq code="\text{count} = 7 - 6 = 1" />
9. Intervals with ending points before the end of `t`: <Eq code="\text{count} = 7 - 3 = 4" />

Unsurprisingly, the numbers of the opposites are the same since our example is quite symmetrical.

The theoretically useful thing here is that it's relatively quick (<Eq code="O(\log n)" />) to query the count of these subsets after constructing a BST in <Eq code="O(n \log n)" />. So maybe we can construct an equation that simply operates on the sizes of these subsets?

However, I feel like it's unlikely to be a useful solution since you need to be able to query for both the start and end points simultaneously.

Let's play around with the example a bit.

A good place to start might be #2 (intervals with starting points after the start of `t`):

```
     t====
       a-
      b--
        d---
           f---
```

But how do we filter out interval `d` and `f`?

Let's try just querying for #5 (intervals with ending points after the start of `t`):

```
     t====
        d---
           f---
 g------------
```

But how do we filter out interval `g` from query #5?

I haven't figured a solution to this problem yet. I imagine it might be possible to prove that this approach is possible or impossible, but I'm not going into that right now.
</SpoilerBlock>

An evolution of the idea might be to incrementally build the cumulative counts data structure as you iterate through the list of ranges, sorted by starting point.

<SpoilerBlock buttonLabel={"explanation of my attempt at a \"gradual cumulative counts\" approach"}>
For example, maybe you start with the intervals at the lowest starting point, which we'll pretend to be <Eq code="1" />. You'd have a cumulative counts data structure for every possible interval since all intervals will start with at least the lowest starting point. You'd go through all the intervals with starting point <Eq code="1" />, querying for the number of intervals with endpoints no further than the currently-visited interval.

After you're done with all intervals with starting point <Eq code="1" />, you go to the next-highest starting point, which let's pretend it's <Eq code="2" />. This requires us to modify the cumulative counts data structure to discard all intervals with starting points before <Eq code="2" />.

This process is simply repeated until we exhaust all intervals.

Alternatively (and probably better), you could do the reverse by starting with the highest starting point and working your way backwards to the lowest starting point.

However, the trouble is finding a data structure that lets you insert fast while also letting you quickly query cumulative counts. A BST in lets you insert in <Eq code="O(\log n)" /> but is probably difficult to get a cumulative count without <Eq code="O(n)" /> sequential counting. A array that we keep sorted lets you get a cumulative count in potentially <Eq code="O(\log n)" /> due to <Eq code="O(\log n)" /> binary search and <Eq code="O(1)" /> count (ignoring multiplicity edge cases for now), but suffers from <Eq code="O(n)" /> insertions.

Therefore, this is probably not the right approach.
</SpoilerBlock>

<p><Todo>Continue!</Todo></p>


## Room Allocation <Spec href="https://cses.fi/problemset/task/1164/" cdate="2024-02-02" />

I attempted a straightforward Python implementation using `heapq` but it TLE's on one test case (a test case that seems quite significantly harder than even my longest-running accepted test case). The solution otherwise seems logically correct, and passes all the other test cases within the time limit:

import SolRoomAllocationFail01 from "./_solutions.sorting-and-searching/room-allocation--fail01-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution">
    <Code code={SolRoomAllocationFail01} lang="py" />
</SpoilerBlock>

Rewriting it in C++ passed all tests:

import SolRoomAllocationAlt01 from "./_solutions.sorting-and-searching/room-allocation--alt01-cleaned-up.cpp?raw" //_

<Code code={SolRoomAllocationAlt01} lang="cpp" />

In an attempt to get a Python solution working, I tried batching start times *(it makes sense in context)* but it generally caused a slight slowdown compared to my first Python attempt:

import SolRoomAllocationFail02 from "./_solutions.sorting-and-searching/room-allocation--fail02-useless-optimization.py?raw" //_

<SpoilerBlock buttonLabel={"TLE'd Python \"Start Time Batching\" Solution"}>
    <Code code={SolRoomAllocationFail02} lang="py" />
</SpoilerBlock>

I also tried taking it further by replacing the priority queue with a sorted queue, but it was even slower:

import SolRoomAllocationFail05 from "./_solutions.sorting-and-searching/room-allocation--fail05-useless-optimization.py?raw" //_

<SpoilerBlock buttonLabel={"TLE'd Python \"Ghetto Priority Queue\" Solution"}>
    <Code code={SolRoomAllocationFail05} lang="py" />
</SpoilerBlock>


## Factory Machines <Spec href="https://cses.fi/problemset/task/1620/" cdate="2024-02-05" />

The first thing I tried was a relatively naive <Eq code="O(n + t \log n)" /> solution, but I didn't properly read the problem bounds at the time, which says <Eq code="1 \le t \le {10}^9" />. With these bounds, it's clear why it doesn't pass. I wrote it in Python and then rewrote in C++:

import SolFactoryMachinesFail01 from "./_solutions.sorting-and-searching/factory-machines--fail01-tle.py?raw" //_
import SolFactoryMachinesFail02 from "./_solutions.sorting-and-searching/factory-machines--fail02-tle.cpp?raw" //_

<SpoilerBlock buttonLabel="TLE'd Naive Solution (Python)">
    <Code code={SolFactoryMachinesFail01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="TLE'd Naive Solution (Rewrote in C++)">
    <Code code={SolFactoryMachinesFail02} lang="cpp" />
</SpoilerBlock>

The next thing I did was a very low-effort adaptation to start with a binary search to go almost the whole way, and then getting the final solution by applying my original naive solution, which wouldn't have a lot left to do after binary search has already done the work. It's almost certainly possible to just make it a pure binary search, but doing it this way allows me to be lazy and be loose with the algorithm design to at least get something to pass, and I already had the naive code anyway. Unfortunately, it had an extremely trivial bug, causing my initial implementations to TLE:

import SolFactoryMachinesFail04 from "./_solutions.sorting-and-searching/factory-machines--fail04-tle.py?raw" //_
import SolFactoryMachinesFail05 from "./_solutions.sorting-and-searching/factory-machines--fail05-tle.cpp?raw" //_

<SpoilerBlock buttonLabel="TLE'd Buggy Low-Effort Binary Search Solution (Python)">
    <Code code={SolFactoryMachinesFail04} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="TLE'd Buggy Low-Effort Binary Search Solution (Rewrote in C++)">
    <Code code={SolFactoryMachinesFail05} lang="cpp" />
</SpoilerBlock>

The issue was that my binary search only covered outputs of up to <Eq code="2^{32} \approx {10}^9" />. However, outputs could actually be even larger, meaning that if an output was actually something like <Eq code="2^{60} \approx {10}^{18}" />, the second stage of the algorithm (the naive stage) may still have a lot more products left to process.


This actually eluded me for several days until I actually read the test cases I TLE'd on and realized how big the outputs were. The only change I had to make was to change from `bitmask = 1 << 31` to `bitmask = 1 << 63`, leading to my first solution (written in Python and C++) that passes all tests:


import SolFactoryMachines from "./_solutions.sorting-and-searching/factory-machines.cpp?raw" //_
import SolFactoryMachinesAlt01 from "./_solutions.sorting-and-searching/factory-machines--alt01.py?raw" //_

<Code code={SolFactoryMachinesAlt01} lang="py" />

<SpoilerBlock buttonLabel="C++ version of my first solution">
    <Code code={SolFactoryMachines} lang="cpp" />
</SpoilerBlock>

<p><Todo>I think a purely binary search solution should be possible, without the naive heap-based part. I should try it! I'm just feeling a bit lazy rn</Todo></p>

<p><Todo>Is there a nicer solution than binary search? Or maybe a faster way to calculate how many products can be made at a given point in time? It feels like there should be something better.</Todo></p>


## Tasks and Deadlines <Spec href="https://cses.fi/problemset/task/1630/" cdate="2024-02-05" />

I think the key to this question is realizing that even if you finish a task super-early at the expense of doing another task later and possibly even eating a negative reward, the super-early task could cancel it out. Therefore, the most optimal play is to just worry about how fast you can do tasks, and always do the shortest task before a longer task, that way you collect the reward as soon as possible.

import SolTasksAndDeadlines from "./_solutions.sorting-and-searching/tasks-and-deadlines.py?raw" //_

<Code code={SolTasksAndDeadlines} lang="py" />


## Reading Books [UNFINISHED] <Spec href="https://cses.fi/problemset/task/1631" cdate="2024-02-06" />

<p><Todo>I have some ideas, but otherwise haven't come up with a possible solution for this problem yet.</Todo></p>


## Sum of Three Values <Spec href="https://cses.fi/problemset/task/1641" cdate="2024-02-12" />

For a question this simple, this one took an embarrassing amount of time for me to get!

My initial solution was to incrementally build a *sum of two values* dictionary, then for each value, we check if there is a sum of two other values that we can add to it to sum to the target <Eq code="x" />. However, the solution is quite slow:

import SumOfThreeValuesFail02 from "./_solutions.sorting-and-searching/sum-of-three-values--fail02-tle.py?raw" //_

<SpoilerBlock buttonLabel="TLE'd Python Solution">
    <Code code={SumOfThreeValuesFail02} lang="py" />
</SpoilerBlock>

I took an embarrassing amount of time writing increasingly optimized versions of it, and even contemplated redoing it in C++.

However, my breakthrough came after realizing we can run a two-pointer algorithm as the inner loop, which is much lighter-weight than dictionary-building even though they're both <Eq code="O(n^2)" />:

import SumOfThreeValuesAlt01 from "./_solutions.sorting-and-searching/sum-of-three-values--alt01-simplified.py?raw" //_

<Code code={SumOfThreeValuesAlt01} lang="py" />


## Sum of Four Values <Spec href="https://cses.fi/problemset/task/1642" cdate="2024-02-13" />

Having done Sum of Three Values, adapting a similar two-pointer approach was straightforward. My solution builds a sum-of-two-values list and then carries out the two-pointer approach on it:

import SumOfFourValues from "./_solutions.sorting-and-searching/sum-of-four-values.py?raw" //_

<Code code={SumOfFourValues} lang="py" />


## Nearest Smaller Values <Spec href="https://cses.fi/problemset/task/1645/" cdate="2024-02-13" />

Right off the bat, a monotonic stack seems to fit the problem very well. It's a very straightforward algorithm, though my first attempt unfortunately involves a binary search since I was still working through how you'd query the stack:

import NearestSmallerValues from "./_solutions.sorting-and-searching/nearest-smaller-values.py?raw" //_

<SpoilerBlock buttonLabel="Initial Python Solution">
    <Code code={NearestSmallerValues} lang="py" />
</SpoilerBlock>

After submitting that initial solution, I quickly fixed it up to remove the unnecessary binary search:

import NearestSmallerValuesAlt01 from "./_solutions.sorting-and-searching/nearest-smaller-values--alt01.py?raw" //_

<Code code={NearestSmallerValuesAlt01} lang="py" />


## Subarray Sums I <Spec href="https://cses.fi/problemset/task/1660/" cdate="2024-02-13" />

import SubarraySumsI from "./_solutions.sorting-and-searching/subarray-sums-i.py?raw" //_

<Code code={SubarraySumsI} lang="py" />

