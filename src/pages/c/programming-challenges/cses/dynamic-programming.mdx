---
layout: "@layouts/MDLayout.astro"
title: Dynamic Programming - CSES Problem Set Solutions
description: My solutions and thoughts for the CSES problem set!
keywords: ["cp", "competitive programming", "leetcode", "algorithms", "data structures"]
---

import AlignLatex from "@components/latex/AlignLatex";
import DisplayLatex from "@components/latex/DisplayLatex";
import Eqref from "@components/latex/Eqref";
import GatherLatex from "@components/latex/GatherLatex";
import Eq from "@components/latex/Eq";
import Trl from "@components/latex/TableRowLatex";
import Trhl from "@components/latex/TableRowHLatex";

import FigImg from "@components/figures/FigImg";
import FiguresBlock from "@components/figures/FiguresBlock";
import Fig from "@components/figures/Fig";

import Code from "@components/Code.astro";
import SpoilerBlock from "@components/SpoilerBlock.astro";
import Todo from "@components/Todo";

import Spec from "./../_shared.Spec.astro"; //_
import Intro from "./_common.intro.astro"; //_

import DArr from "./_common.DArr.astro"; //_
import UArr from "./_common.UArr.astro"; //_
import LArr from "./_common.LArr.astro"; //_
import RArr from "./_common.RArr.astro"; //_
import DLArr from "./_common.DLArr.astro"; //_
import URArr from "./_common.URArr.astro"; //_


<Intro />


## Dice Combinations <Spec href="https://cses.fi/problemset/task/1633" cdate="2024-03-13" />

The subproblem is simply a Fibonacci-esque recursive function:

<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_n = F_{n-1} + F_{n-2} + F_{n-3} + F_{n-4} + F_{n-5} + F_{n-6}
    \quad\text{for}\quad n > 0
" />

With DP, this runs in <Eq code="O(n)" /> time. Considering how the input bounds set <Eq code="n \le {10}^6" />, a test case can in theory run a hotspot <Eq code="6 \times {10}^6" /> times.

We choose <Eq code="F_{n-1}" /> through to <Eq code="F_{n-6}" /> since we know each dice roll has to be integers 1-6.

My first attempt was a top-down implementation, though it comes to no surprise that it causes runtime errors (presumably stack overflow):

import SolDiceCombinations01 from "./_solutions.dynamic-programming/dice-combinations--01-fail-stackoverflow.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (Stack Overflow)">
    <Code code={SolDiceCombinations01} lang="py" />
</SpoilerBlock>

Setting a higher `setrecursionlimit` fixed the runtime errors, but instead TLE's. Not too surprising. Implementation:

import SolDiceCombinations02 from "./_solutions.dynamic-programming/dice-combinations--02-fail-tle.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Solution (TLE)">
    <Code code={SolDiceCombinations02} lang="py" />
</SpoilerBlock>

Switching to a simple top-down approach passed all tests (worst-case runtime in CPython and PyPy3 was 1.00s and 0.22s, respectively):

import SolDiceCombinations03 from "./_solutions.dynamic-programming/dice-combinations--03-pass.py?raw" //_

<Code code={SolDiceCombinations03} lang="py" />

Switching to only storing a fixed-size window reduced the worst test case runtimes to 0.44s and 0.13s (CPython and PyPy3, respectively):

import SolDiceCombinations04 from "./_solutions.dynamic-programming/dice-combinations--04-pass.py?raw" //_

<Code code={SolDiceCombinations04} lang="py" />

Making it so we don't re-add all six elements of `tab` anymore turned out to perform worse:

import SolDiceCombinations05 from "./_solutions.dynamic-programming/dice-combinations--05-pass.py?raw" //_

<Code code={SolDiceCombinations05} lang="py" />


## Minimizing Coins <Spec href="https://cses.fi/problemset/task/1634" cdate="2024-03-31" />

The first subproblem that comes to mind is, for every integer from <Eq code="0" /> to <Eq code="x" />, we find the fewest number of coins possible. Runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = \infty
    \qquad
    F_0 = 0
    \\
    F_x = \min_{c \in C}\parens{
        F_{x - c}
    } + 1
    \quad\text{for}\quad x > 0
" />

Considering how the input bounds set <Eq code="n \le 100" /> and <Eq code="x \le {10}^6" />, a test case can in theory run a hotspot <Eq code="{10}^8" /> times. Assuming a similar style of implementation to my first Dice Combinations passed solution which had a worst runtime of 0.22s, it doesn't sound like Minimizing Coins in Python should pass since we get a hotspot running at least 10x as many times.

For fun, we start with a Python top-down solution, as well as bottom-up, and I also tried an optimization that precomputes some trivial table entries. The logic appears correct, but they TLE as expected:

import SolMinimizingCoins01 from "./_solutions.dynamic-programming/minimizing-coins--01-fail-tle-topdown.py?raw" //_
import SolMinimizingCoins02 from "./_solutions.dynamic-programming/minimizing-coins--02-fail-tle-bottomup.py?raw" //_
import SolMinimizingCoins03 from "./_solutions.dynamic-programming/minimizing-coins--03-fail-tle-added-precomputes.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolMinimizingCoins01} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution (TLE)">
    <Code code={SolMinimizingCoins02} lang="py" />
</SpoilerBlock>

<SpoilerBlock buttonLabel="Failed Python Bottom-Up Solution With Optimization (TLE)">
    <Code code={SolMinimizingCoins03} lang="py" />
</SpoilerBlock>

Implementing the bottom-up approach in C++ passed all tests (with a longest runtime of 0.15s):

import SolMinimizingCoins05 from "./_solutions.dynamic-programming/minimizing-coins--05-pass-bottomup.cpp?raw" //_

<Code code={SolMinimizingCoins05} lang="cpp" />


## Coin Combinations I <Spec href="https://cses.fi/problemset/task/1635" cdate="2024-04-01" />

Orderings appear significant, which makes subproblem selection easier. My chosen subproblem is to find the number of combinations for each possible target sum <Eq code="0" /> to <Eq code="x" />. For <Eq code="n" /> coins, the runtime is <Eq code="O(xn)" />:

<DisplayLatex code="
    C = \braces{c_0, \dots, c_{n-1}} = \text{set of all coin values}
" />
<GatherLatex code="
    F_{<0} = 0
    \qquad
    F_0 = 1
    \\
    F_x = \sum_{c \in C}{
        F_{x - c}
    }
    \quad\text{for}\quad x > 0
" />

Input bounds are similar to Minimizing Coins, so a hotspot possibly runs <Eq code="{10}^8" /> times, and is similarly unlikely to pass using Python.

But let's write a top-down Python implementation anyway! As expected, it TLE's:

import SolCoinCombinationsI01 from "./_solutions.dynamic-programming/coin-combinations-i--01-fail-tle-topdown.py?raw" //_

<SpoilerBlock buttonLabel="Failed Python Top-Down Solution (TLE)">
    <Code code={SolCoinCombinationsI01} lang="py" />
</SpoilerBlock>

Implementing bottom-up in C++ passes all tests:

import SolCoinCombinationsI02 from "./_solutions.dynamic-programming/coin-combinations-i--02-pass-bottomup.cpp?raw" //_

<Code code={SolCoinCombinationsI02} lang="cpp" />


## Coin Combinations II [UNFINISHED] <Spec href="https://cses.fi/problemset/task/1636" cdate="2024-04-01" />

<Todo>Start this!</Todo>

